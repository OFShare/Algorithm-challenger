### 并查集

模板:

```c++
for (int i = 0; i <= n; ++i)
  fa[i] = i, count[i] =i;

// 函数返回的是x的根节点的编号
int find_union(int x) {
  return x == fa[x]? x: fa[x] = find_union(fa[x]);
}
```

1. 例题[POJ-2236](https://vjudge.net/problem/POJ-2236), AC[源码](./POJ-2236.cc)

   注意距离比较时的精度

2. 例题[POJ-1611](https://vjudge.net/problem/POJ-1611), AC[源码](./POJ-1611.cc)

   先看最开始的超时代码, [tle](./POJ-1611-tle.cc). 当前的人只需和前面一个人进行合并操作即可, 因为前面的人肯定已经在一个联通块了.

3. 例题[HDU-1213](https://vjudge.net/problem/HDU-1213), AC[源码](./HDU-1213.cc)

   并查集求联通块个数


---

### 带权并查集

这是并查集更为高深的应用, 网上几乎没有什么学习资料, 全靠自己脑补QAQ.

其实带权并查集也不是很难, 首先并查集维护的是一个联通块, 常见的就是求联通块的大小, 在这类题型中, 边是没有赋予权值的. 带权并查集就是给这些有向图的边加上权值, 一般权值是**某种关系**. 为什么是有向图, 因为fa[x] = y, 表示x的父亲结点是y, 这里看成x指向y的一条有向边. 然后有向边的权值我们用value[x]表示, 它表示x 指向 y的一条有向边的权值为value[x], 这就是核心的基本思想了.

另外, 在这个**联通块有向图**里任意两点的关系都可以求出来. 其中各种等式都是从**向量加法**思考推导的.

4. 例题[HDU-3038](https://vjudge.net/problem/HDU-3038), AC[源码](./HDU-3038.cc)

   带权并查集入门题, 注意要用左闭右开区间即[x, y), 来表示图上的两结点

5. 例题[POJ-1182](https://vjudge.net/problem/POJ-1182), AC[源码](./POJ-1182.cc)

   带权并查集.

6. 