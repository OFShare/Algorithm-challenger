##### 数学相关

[资料](./math.md)

1. [Aizu-0005](https://vjudge.net/problem/Aizu-0005), [参考代码](./Aizu-0005.cc)

   题意: 求最大公约数, 最小公倍数

   `题解`: gcd(a, b), lcm(a, b)

   时间复杂度: gcd: O( log(max(a, b) ) )

2. [UVA-10006](https://vjudge.net/problem/UVA-10006), [参考代码](./UVA-10006.cc)

   题意: 判断一个数是否是Carmichael Number

   `题解`: Carmichael Number, 它首先不是素数, 然后按定义模拟一下.

   涉及, 判断一个数是否是素数, 快速幂

   时间复杂度: O(N * log N )

3. [Aizu-0009](https://vjudge.net/problem/Aizu-0009), [参考代码](./Aizu-0009.cc)

   题意: 输出小于等于n的素数的个数.

   `题解`: 因为n不大, 直接O(sqrt(n))判断. 可以先打个表, 后面直接输出

   时间复杂度: O(N * sqrt(N))

4. [POJ-1118](https://vjudge.net/problem/POJ-1118), [参考代码](./POJ-1118.cc)

   题意: 给出N个点, 输出在同一直线上的最多的点的个数

   `题解`: 有个很显然的做法, 先选出两个点, 在枚举判断其他点是否在这条直线上. 时间复杂度O(N ^ 3).

   然后我们可以稍微优化下, 先选出一个点, 在算出其他点和这个点的斜率. 然后对算出的斜率排序. 如果斜率相等, 排序后肯定紧靠在一起. 然后统计相等斜率点的个数, 维护答案.

   时间复杂度: O(N * N * log N)

5. [POJ-1995](https://vjudge.net/problem/POJ-1995), [参考代码](./POJ-1995.cc)

   题意: 算出题目给出的式子模M的值.

   `题解`: 直接**快速幂**即可.

   时间复杂度: O(N * log N)

6. [POJ-3641](https://vjudge.net/problem/POJ-3641), [参考代码](./POJ-3641.cc)

   题意: 题目背景**费马小定理**, 判断p不是素数, 却满足题目给出的式子.

   `题解`: 判断素数 + 快速幂

   时间复杂度: 略

7. [POJ-3421](https://vjudge.net/problem/POJ-3421), [参考代码](./POJ-3421.cc)

   题意: 给出X, 求最长链的长度以及对应的个数. 链的定义见题目

   `题解`: 看起来很难. 但是我们把X用**唯一分解定理**表示, 从X倒着出发, 每次除以一个因子, 这样**构造的链**就是最长的. 有多少这样的链, 就是对X的因子**可重元素的排列**: 公式n! / (r1! * r2! * r3! * ... * rk!), 其中r1 + r2 + r3 + ... + rk = n

   时间复杂度: 略

8. [POJ-3126](https://vjudge.net/problem/POJ-3126), [参考代码](./POJ-3126.cc)

   题意: 给你两个四位的素数a，b。a可以改变某一位上的数字变成c，但只有当c也是四位的素数时才能进行这种改变。请你计算a最少经过多少次上述变换才能变成b。

   `题解`: **隐式图搜索**, 从a进行bfs搜索, 转移的条件是改变一位数字后是否还是素数. 进行bfs搜索时, 注意队列里可能有好几个相同状态

   时间复杂度: 略

9. [UVA-11582](https://vjudge.net/problem/UVA-11582), [参考代码](./UVA-11582.cc)

   题意: 求f(a ^ b) % n 的值, f是斐波那契数列.

   题解: 找循环节 + 快速幂. 因为a和b巨大, 所以我们不能直接求. 因为f[i + 2] = f[i + 1] + f[i], 所以两边模n 也是可以的. 即 f[i + 2] % n = (f[i + 1] % n + f[i] % n) % n. **不难发现**(观察大法233333)f[i] % n 这个新的式子在n ^ 2内会出现**循环节**. 所以问题便简单了, 假设循环节为k, index = a ^ b % k便是在循环节数组里的下标, 答案便是循环节数组[index].

   时间复杂度: 略

10. [HDU-2669](https://vjudge.net/problem/HDU-2669), [参考代码](./HDU-2669.cc)

    题意: 给出a和b, 算X * a + Y * b = 1. 输出最小的非负X以及对应的Y

    `题解`: exgcd裸题. 算出通解(x, y), 在根据条件x >= 0求出最小的非负X即可.

    时间复杂度: 略

11. [UVA-11768](https://vjudge.net/problem/UVA-11768), [参考代码](./UVA-11768.cc)

    题意: 求出给定的线段上的整点的个数

    `题解`: 这个题我大概陆续写了好几个晚上, 才过了. 具体做法: 先乘以10, 转换为已知两整点的直线A, 求出直线A上的通解(用exgcd), 设直线上的通解为(x, y), 那么(x / 10, y / 10)便回到了最初的直线上, 我只要判断(x / 10, y / 10)是不是整点就行了, 所以 x, y可以类似等于(120, 130) 那么最初的直线上的点便是(12.0, 13.0), 这样就找到了一个整点.

    上面的做法后面还要一个个判断模10是否等于0比较麻烦. 其实我们可以直接设直线上的整10倍的点为(10x, 10y), 代入ax + by + c = 0中, 则a(10x) + b(10y) + c = 0, 即10ax + 10by + c = 0. 令a = 10a, b = 10b, 则方程又转换为ax + by + c = 0, 只不过现在求的整点(x, y)是10ax + 10by + c = 0上的整点, 在乘以10, 便是整10倍的点, 再除以10, 就回到了题目给出的两点(含一位小数)确定的直线上. 先乘以10再除以10相当于没乘.

    时间复杂度: 略.

12. [UVA-12169](https://vjudge.net/problem/UVA-12169), [参考代码](./UVA-12169.cc)

    题意: 最开始看不懂题意(QAQ). 

    输入T, x 1 , x 3 , ... , x 2T-1 ,输出x 2 , x 4 , ... , x 2T 。其中x序列满足x i =(ax i-1 +b) mod 10001.

    `题解`: 枚举a, b. 知道a, b了那么整个序列就可以按照题目给的递推式推出来, 然后check序列是否满足即可.

    时间复杂度: 略

13. [UVA-10375](https://vjudge.net/problem/UVA-10375), [参考代码](./UVA-10375.cc)

    题意: 求C(p, q) 除以 C(r, s)的值

    `题解`: 直观的想法是把分子的组合数求出来, 再除以分母的组合数. 但是直接求会溢出. 然后我们可以利用**唯一分解定理**, 把分子和分母分别表示出来, 然后就能计算出来了.

    时间复杂度: 略

14. [UVA-10791](https://vjudge.net/problem/UVA-10791), [参考代码](./UVA-10791.cc)

    题意: 给出n, n是至少两个数的最小公倍数, 求这些数的最小和.

    `题解`: 不难发现把n唯一分解定理后, 每个数作为一个单独的整数时最优。注意细节, 至少两个数.

    时间复杂度: 略

15. [UVA-12716](https://vjudge.net/problem/UVA-12716), [参考代码](./UVA-12716.cc)

    题意: 给定N, 求满足gcd(A, B) = A xor B where 1 ≤ B ≤ A ≤ N这个条件的个数.

    题解`: 最能想到的是枚举A, B, 然后check是否满足等式. 这样的时间复杂度为: O(N ^ 2 * log N)显然超时.

    我们简单推一下:

    设gcd(A, B) = A xor B = C

    所以A和B都是C的倍数, 然后注意到异或的一个性质: A xor B = C, A xor C = B.

    所以我们枚举C, 然后A因为是C的倍数, 所以A = C, 2C, 3C, 4C...

    枚举C要O(N)的时间, 枚举A要O(logN), check要O(log N), 所以这样的时间复杂度为: O(N log N * log N), 依然超时.

    然后我们注意到A, B, C满足C = A - B, 这样就不需要O(log N)的检查了, 少了一个log, 所以时间复杂度变为O(N * log N). 另外题目是多组输入, 所以我们可以预先打表, 后面直接输出即可．代码里的sum[n]代表的就是输入为n时, 对应的满足条件的个数.

    时间复杂度: O(N * log N)

16. 