#####  [Codeforces Round #582 (Div. 3)](http://codeforces.com/contest/1213)题解

- A :  有n个芯片，可以免费的向左或向右移动2格，也可以花费一个金币向左或向右移动1格，问最后都移动到相同位置时，最少的花费。

  题解: 枚举移动到每个点的花费，再取个std::min即可。

  [AC源码](./A.cc)

  ---

- B: 有n个数，问在它的右边是否有比它小的数，有的话，对答案贡献加一。

  题解: 我们逆序遍历，维护最小值即可。

  [AC源码](./B.cc)

  ---

- C: 一本书有N页，问在1~N中，是m的倍数的数的个位求和，是多少。

  题解: m * 1 % 10 , m * 2 % 10 , . . . , m * 10 % 10, m * 11 % 10, m * 12 % 10, . . .

  我们发现 m * 1 % 10等于m * 11 % 10, m * 2 % 10等于m * 12 % 10, 依次类推。

  即m * 1 % 10 . . . 一直到 m * 10 % 10构成一个循环节。那么 n / m / 10 便是完整的循环节个数，n / m % 10便是最后一个循环节剩下的元素。

  找到循环节后，便可以轻松AC啦。

  [AC源码](./C.cc)

  ---

- D: 给定n个数，每个数可以除以2，记为一次操作。问最后k个数相等时，最少的操作数。

  题解: 记录每个数除以2后，需要的操作数。最后枚举k个相等的数分别是0~2e5时的操作数，取std::min便是答案。

  [AC源码](./D-solution2.cc)

  ---

- E: 给定长度都为2的s和t串，由{'a', 'b', 'c'}组成。问能否构造一个长度为3 * n的串，要求不能包含s和t子串(连续)。

  题解: 我们先分析当n为1的情况。这时构造的串为abc其中的一个全排列，有6种。而s和t只有2种(不考虑aa bb这样的)，剩下的4种都是合法的情况。

  在考虑n为2，n为3，...的情况，一直按n=1的时候重复下去。

  这样我们便构造了6种，即(abc的全排列，3 * 2 * 1)。

  当s串为bc, t为cb时，发现这6种串都包含的s和t。说明我们还少构造了一些情况。

  剩下的情况可以构造a...ab...bc...c这样的，abc也可以互换位置，也是6种。

  这样我们便构造了6 + 6 = 12种情况。答案一定是YES。

  [AC源码](./E.cc)

  ---

- G: 给出n个点的树，和m个询问。每个询问是，对于给定的qi，树中简单路径的最大的权重不超过qi的路径条数。

  题解: 我们先思考这种情况，假设有一个点u，它的联通块数为a(联通块内权重都小于u v之间的权重)，另外一个点v，它的联通块数为b(同样的联通块内权重也都小于u v之间的权重)。将u和v连接起来，那么对于不超过权重u v，的路径条数为 a * b。(即在u的联通块内选一个点，在v的联通块内选一个点）

  这样，我们把树的权重从小到大排序，依次添加，联通块用并查集维护。

  [AC源码](./G.cc)

  

  

   



