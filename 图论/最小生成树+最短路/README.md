##### 最小生成树

- **Prim**

  简单的说就是, 每次从未标记的点集合里选一个距离标记点集合最近的一个点u, 它离标记点集合的距离贡献给最小生成树, 然后去更新和u相连接的未标记点的距离. 重复上述过程即可. 最开始, 选中的点u, dis[u] = 0, 加入优先队列里. 优先队列是按(距离, 点的编号)保存的, 这样每次出队列时才是未标记的距离标记集合最近的点出队列. 

  注意代码里用的是**链式前向星存图**, 它的介绍可以看[这篇文章](https://blog.csdn.net/acdreamers/article/details/16902023), 而且模板代码里有比较详细的注释

  [模板例题P3366](https://www.luogu.org/problem/P3366), [模板代码](./P3366.cc)

  时间复杂度: O( E * log V ), E是边数, V是顶点数(下同)

- **Kruskal**

  将边按权值从小到大排序, 然后依次取边, 取出的边判断两端点是否是在一个联通块, 不在就连接, 边的权值贡献给最小生成树, 联通块的判断用并查集维护即可.

  [模板例题P3366](https://www.luogu.org/problem/P3366), [模板代码](./P3366-solution2.cc)

  时间复杂度: O(E * log E) 

---

##### 最短路

- **Floyd**

  本质是dp, 所以我们先用dp实现一遍. 

  定义dp\[k]\[i]\[j]为: 在只使用1, 2, 3, ..., k结点的情况下(可以都不用), 从结点i走到结点j最短的路径.

  状态转移为: 考虑k这个结点, 经过和不经过即可。

  [模板例题P3905](https://www.luogu.org/problem/P3905), [模板代码-dp实现](./P3905-solution2.cc)

  接着我们压缩掉第一维, 便是我们常见的Floyd写法了. (如果写滚动数组的话, 稍微有点麻烦, 我就不实现啦)

  [模板代码-常见实现](./P3905.cc)

  时间复杂度: O(N ^ 3)

- **Dijkstra**

  处理非负边权.

  定义dis[i]为从源点到结点i的最短路径. 每次从优先队列里弹出dis最小的点, 如果它未被访问(即标记)过, 就用它更新它相邻的点, 并将可以更新的点入队列. 重复上述过程, 直到队列为空, 或者终点已被标记, 则可结束算法. 

  它的实现和**Prim**非常类似, 只是在**Prim**中, dis[i]记录的是结点i距离已标记集合最短的距离, 而在**Dijkstra**中,dis[i]记录的是从源点到结点i的最短路径.

  [模板例题P4779](https://www.luogu.org/problem/P4779), [模板代码](./P4779.cc)

  时间复杂度: O(E * log V)

- **Bellman_Ford**

  可以处理负边权.

  也即大家口中说的SPFA算法. 它的实现其实和Dijkstra是类似的.

  同样定义dis[i]为从源点到结点i的最短路径, 每次选出所有的边进行松弛操作, 直到图中不能进行松弛操作, 算法结束. 如果图存在最短路, 则最多进行(顶点数n - 1)次松弛操作, 即当是一条链的情况. 如果第n次还可以进行松弛操作, 说明图中存在负环.

  松弛操作即: if(dis[u] + w < dis[v]) dis[v] = dis[u] + w; 即把dis[v]变小, 好像把它松弛了, 所以叫松弛操作.

  [模板例题P3385](https://www.luogu.org/problem/P3385), [模板代码](./P3385.cc)

  时间复杂度: O(E * V)

---

小结: 可以发现以上5种基本的图论算法, 十分类似, 有很多相同的地方. 希望大家多用类比的方式思考问题.

掌握了以上基本的算法, 接下来我们就可以去刷一些相关的题, 熟悉套路以及加深理解.

1. [P1144](https://www.luogu.org/problem/P1144), AC[源码](./P1144.cc)

   题意: 给出一个N顶点M条边的无向无权图, 顶点编号为1 ~ N . 问从顶点1开始, 到其他每个点的最短路有几条.

   `题解`: 多用一个数组ans[i]: 表示从源点到结点i最短路的条数. 在用**Dijkstra**更新最短路的时候, 也同时更新ans数组即可. 

   时间复杂度: O(E * log V)

2. [P1608](https://www.luogu.org/problem/P1608), AC[源码](./P1608.cc)

   题意: 略

   `题解`: 本题和例题1是类似的, 但是本题注意输入有重复的边, 需要去重. 然后解法和上个题一样.

   时间复杂度: O(E * log V)

3. [P1629](https://www.luogu.org/problem/P1629), AC[源码](./P1629.cc)

   题意: 有一个邮递员要送东西, 邮局在节点1.他总共要送N-1样东西, 其目的地分别是2~N.求送完这N-1样东西并且最终回到邮局最少需要多少时间.

   `题解`: 送的过程是一个出发点到多个目的地, 即1对多, 跑单源最短路**Dijkstra**即可. 难点是回来的时候, 是多对1. 回来的时候, 我们可以建立**反向图**, 这样就又变成1对多的情况, 再跑一遍单源最短路**Dijkstra**即可.

   反向图: 即u - - -  > v, 改为u < - - - v. 即结点u 到结点v, 改为结点v 到结点u.

   时间复杂度: O(E * log V)

4. [P1342](https://www.luogu.org/problem/P1342), AC[源码](./P1342.cc)

   题意: 略

   `题解`: 本题和例题3是类似的, 但是本题要开long long即可.

   时间复杂度: O(E * log V)

5. [P1119](https://www.luogu.org/problem/P1119), AC[源码](./P1119.cc)

   题意: 给定N个顶点和M条边, 每个顶点有个修建完成的时间. 顶点编号越小, 越先修建完成. 有q个询问, 对每一个询问(x, y, t)输出对应的答案，即在第t天，从村庄x到村庄y的最短路径长度为多少。

   `题解`: 最暴力的方法, 即对每个询问跑最短路算法. 这样显然超时.

   我们发现, 顶点修建完成的是按时间从小到大排序的, 我们知道**Floyd**算法的本质其实是dp, 本题就需要把最外面一层的k拎出来. 这样表示只用顶点编号1, 2, 3, . . . , k, 从顶点i 到顶点j的最短路.

   另外如果有这样一个情况1---3 ----2, 即顶点1 连接顶点3, 顶点3连接2. 如果此时k 等于1, 即顶点1 和顶点2 已经修建好了, 这时根据题目的定义, 顶点1到顶点3是不能到达的, 因为顶点3未修建完成, 不可到达. 但是此时dis\[1]\[3] = weight(1, 3) = w. 即此时顶点1到顶点3的最短路是w, 但是并不是题目定义的最短路. 这样也解释了最开始的时候dis\[i]\[j] = weight(1, 3), 尽管最开始顶点都是未修建的, 但是我们任然需要记录, 一旦修建完成就是dis\[i]\[j]了. 

   时间分钟: O(N ^ 3)

6. [POJ-3255](https://vjudge.net/problem/POJ-3255), AC[源码](./POJ-3255.cc)

   题意: 求次短路, 而不是最短路.

   `题解`: 和求最短路类似, 多用一个数组dis2维护次短路. 优先队列里, 最短路, 次短路都入队列里, 再弹出来后, 注意如何更新dis最短路和dis2最短路.

   给组数据: 

   2 1

   1 2 1

   答案是3, 到2的最短路是1, 次短路是3(即从2再走回1再回到2)

   ps: 求k短路呢?

   时间复杂度: O(E * log V)

   ---

   小结: 上面的6道例题, 大多都是类似的, 它们都是多用了一个数组维护相关的信息, 如最短路条数, 次短路. 希望大家多用类比的思维思考.