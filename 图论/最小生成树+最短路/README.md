##### 最小生成树

- **Prim**

  简单的说就是, 每次从未标记的点集合里选一个距离标记点集合最近的一个点u, 它离标记点集合的距离贡献给最小生成树, 然后去更新和u相连接的未标记点的距离. 重复上述过程即可. 最开始, 选中的点u, dis[u] = 0, 加入优先队列里. 优先队列是按(距离, 点的编号)保存的, 这样每次出队列时才是未标记的距离标记集合最近的点出队列. 

  注意代码里用的是**链式前向星存图**, 它的介绍可以看[这篇文章](https://blog.csdn.net/acdreamers/article/details/16902023), 而且模板代码里有比较详细的注释

  [模板例题P3366](https://www.luogu.org/problem/P3366), [模板代码](./P3366.cc)

  时间复杂度: O( E * log V ), E是边数, V是顶点数(下同)

- **Kruskal**

  将边按权值从小到大排序, 然后依次取边, 取出的边判断两端点是否是在一个联通块, 不在就连接, 边的权值贡献给最小生成树, 联通块的判断用并查集维护即可.

  [模板例题P3366](https://www.luogu.org/problem/P3366), [模板代码](./P3366-solution2.cc)

  时间复杂度: O(E * log E) 

---

##### 最短路

- **Floyd**

  本质是dp, 所以我们先用dp实现一遍. 

  定义dp\[k]\[i]\[j]为: 在只使用1, 2, 3, ..., k结点的情况下(可以都不用), 从结点i走到结点j最短的路径.

  状态转移为: 考虑k这个结点, 经过和不经过即可。

  [模板例题P3905](https://www.luogu.org/problem/P3905), [模板代码-dp实现](./P3905-solution2.cc)

  接着我们压缩掉第一维, 便是我们常见的Floyd写法了. (如果写滚动数组的话, 稍微有点麻烦, 我就不实现啦)

  [模板代码-常见实现](./P3905.cc)

  时间复杂度: O(N ^ 3)

- **Dijkstra**

  处理非负边权.

  定义dis[i]为从源点到结点i的最短路径. 每次从优先队列里弹出dis最小的点, 如果它未被访问(即标记)过, 就用它更新它相邻的点, 并将可以更新的点入队列. 重复上述过程, 直到队列为空, 或者终点已被标记, 则可结束算法. 

  它的实现和**Prim**非常类似, 只是在**Prim**中, dis[i]记录的是结点i距离已标记集合最短的距离, 而在**Dijkstra**中,dis[i]记录的是从源点到结点i的最短路径.

  [模板例题P4779](https://www.luogu.org/problem/P4779), [模板代码](./P4779.cc)

  时间复杂度: O(E * log V)

- **Bellman_Ford**

  可以处理非负边权.

  也即大家口中说的SPFA算法. 它的实现其实和Dijkstra是类似的.

  同样定义dis[i]为从源点到结点i的最短路径, 每次选出所有的边进行松弛操作, 直到图中不能进行松弛操作, 算法结束. 如果图存在最短路, 则最多进行(顶点数n - 1)次松弛操作, 即当是一条链的情况. 如果第n次还可以进行松弛操作, 说明图中存在负环.

  松弛操作即: if(dis[u] + w < dis[v]) dis[v] = dis[u] + w; 即把dis[v]变小, 好像把它松弛了, 所以叫松弛操作.

  [模板例题P3385](https://www.luogu.org/problem/P3385), [模板代码](./P3385.cc)

  时间复杂度: O(E * V)

---

小结: 可以发现以上5种基本的图论算法, 十分类似, 有很多相同的地方. 希望大家多用类比的方式思考问题.

掌握了以上基本的算法, 接下来我们就可以去刷一些相关的题, 熟悉套路以及加深理解.

