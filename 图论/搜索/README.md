1. 例题[POJ-1979](https://vjudge.net/problem/POJ-1979), 参考[代码](./POJ-1979.cc)
  
   题意: 给出一个矩形地图, 你最初站在以"@"标示的位置上, 可以上下左右走, 问能访问到的black tiles数量.
   
   `题解`: 定义从(x, y)出发能够遍历的最多的black tile. 从起点深搜索, 即dfs. 
   
   时间复杂度: O(N)

2. 例题[Aizu-0118](https://vjudge.net/problem/Aizu-0118), 参考[代码](./AOJ-0118.cc)
   
   题意: 在H * W的矩形果园里有苹果、梨、蜜柑三种果树， 相邻（上下左右）的同种果树属于同一个区域，给出果园的果树分布，求总共有多少个区域。 （原题的样图中苹果为リ，梨为カ，蜜柑为ミ， 图中共10个区域）输出其区域的个数。
   
   `题解`: 从每个点dfs, 并对访问过的点打上标记. 这样dfs的次数便是答案。
   
   时间复杂度: O(N)
   
3. 例题[Aizu-0033](https://vjudge.net/problem/Aizu-0033), 参考[代码](./AOJ-0033.cc)

   题意: 现给出从A放入小球的顺序，请你判断能否最终小球落入B和C时，号码大的球总是位于号码小的球的上侧。如果可能则在一行中输出”YES”，否则输出 “NO”

   `题解`: 一共10个小球, 小球落下时要么左边, 要么右边, 一共有2 ^ 10状态. 深搜即可. 定义从1~point的球都已经落下的情况, 即前面每个球落在哪里已经确定了.

   另外可以加个很明显的剪枝, 只有现在的球比桶里的球大才放进去, 我的实现代码并没有加上这一优化.

   时间复杂度: O(2 ^ N)

4. 例题[POJ-3009](https://vjudge.net/problem/POJ-3009), 参考[代码](./POJ-3009.cc)

   题意: 问从s 走到g 的最少步数. 其他描述见原题.

   `题解`: 因为碰到一个block后, 会把它变成vacant square, 然后停在它的面前. 然后接着从这个局面(状态)搜索下去, 所以是一道很明显的dfs + 回溯. 即返回状态时, 记得把原来变成vacant square的变回来.

   另外注意这组数据: 

   ```
   6 1
   1 1 2 1 1 3
   ```

   输出为-1, 暗示必须有可以缓冲的空间才可以走.

   我的实现代码比较冗长, 也可以参考这份[代码](./POJ-3009-2.cc)

   时间复杂度: 略

5. 例题[POJ-3669](https://vjudge.net/problem/POJ-3669), 参考[代码](./POJ-3669.cc)

   题意: 有m个流星坠落, 有落下的坐标和时间, 问走到一个安全的地方, 即始终没有被流星摧毁的地方需要的时间.

   `题解`: 从起点bfs下去, 如果队列为空还没找到返回-1.

   注意, 人不会在一个坐标点停留的, 即他会一直走下去, 因为他停在一个坐标点的时间可能会有落下更多的流星摧毁坐标. 所以他会不断走.

   时间复杂度: O(N)
   
6. 例题[Aizu-0558](https://vjudge.net/problem/Aizu-0558#author=underchange), 参考[代码](./Aizu-0558.cc)

   题意: 简单来说就是让你求从起点‘S’到‘1’,‘1’到‘2’，‘2’到‘3’…‘n-1’到‘n’的最短距离.

   `题解`: 定义一个bfs函数, 从start -> end需要最少的步数. 

   注意为了方便可以把图的 'S' 和数字都改成 '.', 这样图就只有‘X' 和 '.' 了, 便于处理.

   时间复杂度: O(N)

7. 例题[Aizu-0121](https://vjudge.net/problem/Aizu-0121), 参考[代码](./Aizu-0121.cc)

   题意: 求给定一个2*4的带号码的方格，每次可以交换 0和相邻的数，问给定起始状态，最少需要多少步交换可以达到目标状态.

   `题解`: 因为终点的状态是已知的, 而且输入有多组, 所以可以**反向bfs**, 即从目标状态出发遍历所有它能走到的状态, 并记录下, 然后对于输入的状态, 查表即可.

   对于这类**典型的八数码问题**, 我这里提供了两种写法, 主要是定义状态的区别.

   [写法1](./Aizu-0121.cc), 这份代码是用字符串表示方格状态, 字符串(一维) 和 方格矩阵(二维) 的映射(即一一对应)
   
   [写法2](./Aizu-0121-solution2.cc), 这份代码是用matrix表示方格状态, 在这份代码里, 你可以学习到如何传递一个二维数组(即matrix).
   
   此外对于搜索的题, 都要注意**判重**, 相同的状态就不需要重新搜索了.
   
   时间复杂度: 略
   
8. 例题[POJ-2718](https://vjudge.net/problem/POJ-2718), 参考[代码](./POJ-2718.cc)

   题意: 给定n个( n <= 10)互不相同的0 ~ 9的数字, 问分成两部分, 相减最少的差异.

   `题解`: 求出n个数字的全排列, 分成2部分相减, 维护最少值.

   本题难点就是如何求**全排列**. 对于全排列, c++ 标准库提供了std::permutation(vec.begin(), vec.end())的高效求法.

   全排列也可以自己用dfs + 回溯实现. 将每个数字看成图上的点, 每个点都和其余的点有边连接. 从每个点出发, 访问一遍图上的点, 所有的排列构成了全排列.

   但是自己实现的全排列明显没有标准库的快, 提交TLE了[参考代码-TLE](./POJ-2718-tle.cc)
   
   时间复杂度: 略
   
9. 例题[POJ-3187](https://vjudge.net/problem/POJ-3187), 参考[代码](./POJ-3187.cc)

   题意: 给定n 和 sum, 求符合题意的n的一个排列

   `题解`: 全排列, 然后判断排列是否符合题意.

   时间复杂度: O(N!)

10. 例题[POJ-3050](https://vjudge.net/problem/POJ-3050), 参考[代码](./POJ-3050.cc)

    题意: 给定一个5 * 5的图, 问从任何一个点出发, 走5步后, 组成的字符串的个数.

    `题解`: 从每个点dfs即可, 把结果放到std::set里, 最后输出std::set的大小便是答案.

    时间复杂度: 略

11. 例题[Aizu-0525](https://vjudge.net/problem/Aizu-0525), 参考[代码](./Aizu-0525.cc)

    题意: 给出n行m列的0、1矩阵，每次操作可以将任意一行或一列反转，即这一行或一列中0变为1，1变为0。问通过任意多次这样的变换，最多可以使矩阵中有多少个1。

    `题解`: 我们先想一下, 如果只能对列进行翻转, 那么我们是不是直接遍历一遍列即可, 当前这一列1的个数多余0就不翻转, 否则翻转. 然后我们枚举有哪些行翻转, 便顺利解决了这道看似难的题.

    枚举有那些行可以翻转, 可以借助二进制, 可以参考下面的snippet
    ```
    for (int i = 0; i < (1 << n); ++i) 
          for (int k = 0; k < n; ++k) {
            // 翻转第k行
            if (i & (1 << k)) {
              flip_row(k, tmp);
            }
          }
    ```      
    时间复杂度: 略

12. ---

    小结: 上面11道例题便是基本的搜索题, 主要是基本的dfs + 回溯, bfs. 后续还会写一些相对高级的搜索.

13. 这篇博客对于搜索也写的挺不错的, 推荐给大家[搜索入门](https://blog.csdn.net/WhereIsHeroFrom/article/details/78921973)
