1. 例题[POJ-1979](https://vjudge.net/problem/POJ-1979), 参考[代码](./POJ-1979.cc)
   题意: 给出一个矩形地图, 你最初站在以"@"标示的位置上, 可以上下左右走, 问能访问到的black tiles数量.
   `题解`: 定义从(x, y)出发能够遍历的最多的black tile. 从起点深搜索, 即dfs. 
   时间复杂度: O(N)

2. 例题[Aizu-0118](https://vjudge.net/problem/Aizu-0118), 参考[代码](./Aizu-0118.cc)
   题意: 在H * W的矩形果园里有苹果、梨、蜜柑三种果树， 相邻（上下左右）的同种果树属于同一个区域，给出果园的果树分布，求总共有多少个区域。 （原题的样图中苹果为リ，梨为カ，蜜柑为ミ， 图中共10个区域）输出其区域的个数。
   
   `题解`: 从每个点dfs, 并对访问过的点打上标记. 这样dfs的次数便是答案。
   
   时间复杂度: O(N)
   
3. 例题[Aizu-0033](https://vjudge.net/problem/Aizu-0033), 参考[代码](./Aizu-0033.cc)

   题意: 现给出从A放入小球的顺序，请你判断能否最终小球落入B和C时，号码大的球总是位于号码小的球的上侧。如果可能则在一行中输出”YES”，否则输出 “NO”

   `题解`: 一共10个小球, 小球落下时要么左边, 要么右边, 一共有2 ^ 10状态. 深搜即可. 定义从1~point的球都已经落下的情况, 即前面每个球落在哪里已经确定了.

   另外可以加个很明显的剪枝, 只有现在的球比桶里的球大才放进去, 我的实现代码并没有加上这一优化.

   时间复杂度: O(2 ^ N)

4. 例题[POJ-3009](https://vjudge.net/problem/POJ-3009), 参考[代码](./POJ-3009.cc)

   题意: 问从s 走到g 的最少步数. 其他描述见原题.

   `题解`: 因为碰到一个block后, 会把它变成vacant square, 然后停在它的面前. 然后接着从这个局面(状态)搜索下去, 所以是一道很明显的dfs + 回溯. 即返回状态时, 记得把原来变成vacant square的变回来.

   另外注意这组数据: 

   ```
   6 1
   1 1 2 1 1 3
   ```

   输出为-1, 暗示必须有可以缓冲的空间才可以走.

   我的实现代码比较冗长, 也可以参考这份[代码](./POJ-3009-2.cc)

   时间复杂度: 略

5. 例题[POJ-3669](https://vjudge.net/problem/POJ-3669), 参考[代码](./POJ-3669.cc)

   题意: 有m个流星坠落, 有落下的坐标和时间, 问走到一个安全的地方, 即始终没有被流星摧毁的地方需要的时间.

   `题解`: 从起点bfs下去, 如果队列为空还没找到返回-1.

   注意, 人不会在一个坐标点停留的, 即他会一直走下去, 因为他停在一个坐标点的时间可能会有落下更多的流星摧毁坐标. 所以他会不断走.

   时间复杂度: O(N)