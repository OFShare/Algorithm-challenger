##### 动态规划讲解

精选了一些dp例题，每道例题都给出ac代码，并详细讲解。量在于多，也在于精。

~~TODO [kuangbin带你飞](https://cn.vjudge.net/article/187) **专题十二 基础DP1** `19/19`~~

TODO [紫书](https://github.com/OFShare/aoapc-bac2nd/tree/master/ch9) **第九章 动态规划例题** `6/31`

~~TODO [背包九讲](https://github.com/OFShare/pack)~~

---

1. 例题[POJ-3176](https://vjudge.net/problem/POJ-3176) ，AC[源码](./POJ-3176.cc)

   题意：给一个数字三角形，问从top走到底部能获得的最大分数是多少？只能沿着两对角线向下走。

   `题解`：定义dp\[i][j]为从顶部向下走，走到第i层j列的最优分数。一层一层的往下走，每一层记录所有可能的值，然后去更新下一层，最后对底部所有可能的值取max就是最终的答案。

   时间复杂度：O(n^2)

2. 例题[POJ-3624](https://vjudge.net/problem/POJ-3624) ，AC[源码](./POJ-3624.cc)

   题意：给定N个小饰品，每个小饰品有重量W和渴望值D且最多选一个，问不超过重量M的情况下，最大的D是多少？

   `题解`：定义dp\[i][j]为第1种物品一直到第i种物品，在选取重量不超过j的情况下，能获得的最大渴望值D。想象下把N种物品排成一行：第1种物品，第2种物品，第3种物品，. . . ，直到第N种物品。一层一层的往右边走，每一层记录所有可能的值，然后去更新下一层，最后答案为dp\[n][M]。

   源码实现用了滚动数组，利用了奇偶性，防止一些题会被内存卡掉。阅读代码时去掉"&1"的操作，就是正常空间大小的dp实现。
   
   这题就是大家常说的经典01背包问题模板题。
   
   时间复杂度：O(N*M)
   
3. 例题[POJ-2229](https://vjudge.net/problem/POJ-2229)， AC[源码](./POJ-2229.cc)

   题意：给定一个数字N，问由2的幂组成的和为N的由多少种。2的幂从小到大排序，即不重复计数。

   `题解`：对答案进行dp，即定义dp\[i]为组成和为i的2的幂的种数。想象下，把1 2 3 4 5 . . . 排成一排，dp\[i]去更新dp\[i+1]和dp\[2*i]。答案便是dp\[N]。

   为什么是这样更新，看下面的1和2的等式。

   1 = 2^0

   2 = 2^0 + 2^0

   2 = 2^1

   一开始我写了[暴力枚举](./POJ-2229-timeout.cc)每种组合情况，这应该是一般人都会想到的做法，但显然会超时。另外看到数据范围是(1 <= N <= 1,000,000)，如果想到是dp的话，应该能猜到是一维的dp即对答案dp，这样时间复杂度才满足要求。

   时间复杂度：O(N)

4. ------

   小结：可以看到前3题都是类似的dp，一层一层的走，都是用一个已经更新好的状态(即从出发走到当前的最优状态)去更新这个状态能转移到的其他状态。能转移到的状态可能是接下来的一层如例题1，也可能是跳了几层如例题3，第i层去更新第2*i层。因为每一层都是从出发走到当前的最优值，这样层层更新下去，得到的结果一定是最优的。

   还有其他更新dp的方式，如有一个dp方程式dp[i] = dp[i-1] + dp[i-2]，这样的dp是dp[i]这个状态由dp[i-1]和dp[i-2]这两个状态组成/更新。

   例题1 2 3，我的dp实现方式都是用某个状态去更新它能转移到的状态。本质上这两张方法都是一样的。

   希望大家用类比的方式思考，理解。

5. 例题[POJ-2385](https://vjudge.net/problem/POJ-2385)， AC[源码](./POJ-2385.cc)

   题意：有两颗苹果数(标记为树0，树1)，每一秒钟从其中的一颗苹果树掉落一个苹果，你可以瞬间移动到一颗苹果树下，问当你第1秒钟站在苹果树0的下面，移动不差过W步时，T时间内最多能接到的苹果数量。

   `题解`：定义dp\[i][j]为从第0秒到第i秒钟，走了j步，能获得的最大苹果数量。时间序列，0秒 1秒 2秒 3秒 4秒 . . . 排成一排，状态转移就是要么移动，要么不动两种情况。另外因为第一秒在树0下面，那么走1步一定是在树1下面，走2步在树0下面，. . . ，所有走j步一定在(j%2)树下面。所有dp\[i][j]这个状态下，你是知道你在那颗树下面的。

   最后的答案就是std::max(dp\[T][0]，dp\[T][1]，. . . ，dp\[T][W])。

   例题1到例题5是不是很像一类题，但是你会发现例题1最简单，为什么呢？因为例题1显示的告诉你只能往对角线走，这其实就是告诉你dp的状态如何转移。到后面你会发现dp的转移很是关键，也是问题的难点。题目不会显示的告诉你如何转移，都要自己分析得出。

   时间复杂度：O(T*W)

6. 例题[POJ-3616](https://vjudge.net/problem/POJ-3616)， AC[源码](./POJ-3616.cc)

   题意：有M个时间区间，每个时间区间有个efficiency效率值。奶牛在某个时间区间工作后，必须休息R时间。问合理安排奶牛的工作，能获得最大多少效率值。

   `题解`：首先对区间按结束时间从小到大排序，然后定义dp[i]为从第1个时间区间到第i个时间区间，第i个时间区间工作时，能获得的最大效率值。那么dp[i]的状态只能由前面第1个时间区间到第i-1个时间区间转移而来。当然dp[i]的最小值为第i个时间区间本身的效率值，因为第i个时间区间本身要工作。

   最后的答案就是std::max(dp[1]，dp[2]，. . . ， dp[M])。

   对区间按结束时间从小到大排序，可以简单的理解为，越早结束就能更快接着干事情啦。

   此题的N是多余的条件，最开始围绕N想dp解法，一直没想出来，1 ≤ *N*≤ 1,000,000。

   例题6，我的dp方程是 某个状态从某些状态转移而来，而不是例题1到例题5的，从某个状态去更新它能转移到的其他状态。例题6，如果也用例题1到例题5的写法
   会发现dp的转移不是那么直接，好写。

   所以大家尽量两种dp的写法都要熟悉。

   时间复杂度：O(M*M)

7. 例题[POJ-3666](https://vjudge.net/problem/POJ-3666)， AC[源码](./POJ-3666.cc)

   题意：给你Ｎ个数字，问将Ｎ个数字修改为单调序列的最小修改量。修改量的定义见题目描述。

   `题解`：首先应该要想到，每个数字只能修改为原数组中的其中一个。把这Ｎ个数字排成一排，第一个数，第二个数，. . . ，第Ｎ个数，定义dp\[i][j]为第1个数到第i个数中，将第i个数排在末尾且将第i个数修改为第j大时，目前为止总共最小的修改量。那么状态转移方程为dp\[i][j] = std::min(dp\[i-1][k])，其中1<=k<=j。

   比如说有A[1] = 10, A[2]=11, A[3] = 12，A[4] = 13，那么第一大的数为10,第二大的为11，第三大的为12。那么dp\[２][４]的意思就是在第1个数到第2个数中，将第2个数修改为第4大的数，即11修改为13，然后排在末尾的最小修改量。

   按状态转移直接写的话是O(N^3)，但是有个很显然的优化，更新dp\[i][j]的时候，只要记录了上一层的dp\[i-1][1]，dp\[i-1][2]，. . . ，dp\[i-1][j]的最小值就行了。这样就不用遍历k了，降为O(N^2)。

   最开始做这题时，想了一天也没有想到解法。然后看了网上的题解，发现大部分题解，定义的dp状态都不是很清楚。另外这题本来是求单调非递减和单调非递增的最小修改量。但是数据只有单调非递减的，所以上面的dp解法都是针对单调非递减的，当然可以同理求单调非递增。

   时间复杂度：原始为O(N^3)优化后为O(N^2)
   
8. 例题[POJ-1742](https://vjudge.net/problem/POJ-1742)， AC[源码](./POJ-1742.cc)

   题意：给定N种数字，每种数字有C[i]种，判断是否可以从这些数字之中选出若干使他们的和恰好为K.1<=K<=m

   `题解`：可以直观的定义dp\[i][j]为前i种(第一种1到第i种)，能否组成j。状态转移便是dp\[i][j] |= dp\[i-1][j-k*A[i]]，其中"|="符号表示按位或。这样定义的dp时间复杂度为O(n\*m\*k)。

   如果我们换种定义方式，便可以优化到O(n*m)。现在我们定义dp\[i][j]为前i种硬币，组成和为j时，第i种最多还能剩下多少。如果前i种硬币不能组成和为j，则我们定义dp\[i][j] = -1。

   则状态的转移为，如果dp\[i-1][j]>=0，则dp\[i][j]显然为第i种本身的数量，如果dp\[i][j-A[i]]>=1，则dp\[i][j]为dp\[i][j-A[i]] - 1，其他情况dp\[i][j] = -1。

   注意dp\[i][j] = dp\[i][j-A[i]] - 1，相信大家看到这个式子脑袋里也会想到，dp\[i][j] = dp\[i][j-2*A[i]] - 2，dp\[i][j]= dp\[i][j-3\*A[i]] - 3，为什么其他状态不更新dp\[i][j]呢，只需要dp\[i][j-A[i]] 这个状态去更新dp\[i][j]呢？其实上面的递推式，dp\[i][j-A[i]]会被dp\[i][j-2\*A[i]]更新，所以dp\[i][j-2\*A[i]] 这个状态就不需要去更新dp\[i][j]了。

   另外这个题需要滚动数组的dp写法，不然会被卡内存。如果你不会滚动数组写法，你可以参考前面的**例题2**。你也可以对比此题的滚动数组写法，和原生的[memoryExceeded](./POJ-1742-memoryExceeded.cc)写法。
   
   另外这题如果把N种数字排成一排，将数看作重量等于价值的物品。则可以定义dp\[i][j]为前i个物品，恰好装进背包容量为j的最大价值。只要dp\[i][j]等于ｊ则表示前i种物品(数字)恰好可以拼凑和为j。这便转换为了经典的01背包问题。
   
   时间复杂度：O(n*m)

9. 例题[POJ-3046](https://vjudge.net/problem/POJ-3046)， AC[源码](./POJ-3046.cc)

   题意：蚂蚁有T个家族，每个家族里的蚂蚁没有区别，总共有A只蚂蚁，现在问：给出每个家族的蚂蚁数量，最多能组合成多少个不同的，集合元素个数为S~B的集合？
   
   简单的说就是：就是给你T个集合，每个集合num[i]个数，这些数排列组合能有多少个，个数为S~B的集合。
   
   `题解`：定义dp\[i][j]为前i种集合，选出j个数组成的组合个数。则状态转移方程便是
   
   <a href="https://www.codecogs.com/eqnedit.php?latex=dp[i][j]&space;=&space;\sum_{k=0}^{min(j,a[i])}dp[i-1][j-k]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i][j]&space;=&space;\sum_{k=0}^{min(j,a[i])}dp[i-1][j-k]" title="dp[i][j] = \sum_{k=0}^{min(j,a[i])}dp[i-1][j-k]" /></a>
   
   如果直接用上面的dp方程，那么时间复杂度便是O(T\*B*k)。下面我们对上式进行优化。
   
   当a[i]<=j时，将上式右边展开得
   
   <a href="https://www.codecogs.com/eqnedit.php?latex=dp[i][j]&space;=&space;dp[i-1][j]&space;&plus;&space;dp[i-1][j-1]&space;&plus;&space;...&space;&plus;&space;dp[i-1][j-a[i]]&space;&plus;&space;d[i-1][j-a[i]]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i][j]&space;=&space;dp[i-1][j]&space;&plus;&space;dp[i-1][j-1]&space;&plus;&space;...&space;&plus;&space;dp[i-1][j-a[i]]&space;&plus;&space;d[i-1][j-a[i]]" title="dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-a[i]] + d[i-1][j-a[i]]" /></a>
   
   <a href="https://www.codecogs.com/eqnedit.php?latex=dp[i][j-1]&space;=&space;dp[i-1][j-1]&space;&plus;&space;dp[i-1][j-2]&space;&plus;&space;...&space;&plus;&space;dp[i-1][j-a[i]]&space;&plus;&space;dp[i-1][j-a[i]-1]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i][j-1]&space;=&space;dp[i-1][j-1]&space;&plus;&space;dp[i-1][j-2]&space;&plus;&space;...&space;&plus;&space;dp[i-1][j-a[i]]&space;&plus;&space;dp[i-1][j-a[i]-1]" title="dp[i][j-1] = dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-a[i]] + dp[i-1][j-a[i]-1]" /></a>   
   
   所以<a href="https://www.codecogs.com/eqnedit.php?latex=dp[i][j]&space;=&space;dp[i-1][j]&space;&plus;&space;dp[i][j-1]&space;-&space;dp[i-1][j-a[i]-1]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i][j]&space;=&space;dp[i-1][j]&space;&plus;&space;dp[i][j-1]&space;-&space;dp[i-1][j-a[i]-1]" title="dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-a[i]-1]" /></a>
   
   当a[i]>j时，同理可得：
   
   <a href="https://www.codecogs.com/eqnedit.php?latex=dp[i][j]&space;=&space;dp[i-1][j]&space;&plus;&space;dp[i][j-1]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i][j]&space;=&space;dp[i-1][j]&space;&plus;&space;dp[i][j-1]" title="dp[i][j] = dp[i-1][j] + dp[i][j-1]" /></a>
   
   这样我们的dp方程就没有K这个变量，时间复杂度降为O(T*B)
   
   时间复杂度：原始O(T\*B\*K)，优化后为O(T\*B)
   
   **update**, 更新一种新的做法:
   
   上面的原始优化做法来自**挑战**白书, 属于**计数dp**中经典的**多重集组合数**, 而且绝大多数网上的题解都是这样的. 今天(2019-12-12)在重做这题时, 经过思考, 我发现可以不用这样麻烦.
   
   我们发现最初的状态转移方程:
   
   如果j <= a[i], 那么求和就是dp\[i - 1][0] + dp\[i - 1][1] + dp\[i - 1]\[2] + ... + dp\[i - 1]\[j].
   
   如果j > a[i], 那么求和就是dp\[i - 1][j - a[i] ] + dp\[i - 1][j - a[i] + 1] + dp\[i - 1]\[j - a[i] + 2] + ... + dp\[i - 1]\[j].
   
   对于这样一段连续的求和, 我们很自然的想到用前缀和维护.
   
   这样我们定义一个sum数组维护每一层的前缀和. 这样转移也可以O(1)实现, 总的时间复杂度还是O(T * B) 
   
   参考[代码](./POJ-3046-solution2.cc)
   
   注意这份代码, 如果数据出满会超内存, 但是POJ这题数据太水, 没有极限数据, 是可以提交AC的.
   
   如果有数据出满, 有极限数据, 我们把代码改成**滚动数组**即可.
   
10. 例题[UVA-1025](https://vjudge.net/problem/UVA-1025)，AC[源码](./UVA-1025.cc)

    题意：有N个车站，一位间谍最开始在车站1，在T时候，他需要在车站N。从车站1有一些列车发车，从车站N也有一些列车发车，且车站1和车站N发的车到站后，便不在掉头往回开了，即是单向的。问间谍前往车站N，在路上所等待的最少时间是多少。

    `题解`：定义dp\[i][j]为在i车站，j时刻时，在路上所等待的总的最少时间。因为最开始在车站1我们是不知道要等待多少时间的，但是我们知道，如果间谍可以在T时间到达车站N，那么此时他的等待时间是0，这样我们可以倒着推出，他在车站1，时刻为0时，在路上所等待的总的最少时间。类似于在时间5，去推时间3的情况，因为时间是从0 1 2 3 4 5 6 . . . T增加的，我们现在是倒着推，即从时间T倒退它前面的时间的情况。

    所以显然dp\[i][j]的状态可以有3种转移，上个状态不乘车，上个状态来自左边乘车而来，上个状态来自右边乘车而来。

    这个题我最开始调了一晚上，没调出来。还有要注意for循环的顺序，在时刻T时，在车站1，车站2，. . . ，车站N的状态都是已知的，所有应该第一个循环是时间，里面的循环是车站。

    还有这个题的代码虽然AC了，但是在UVA的uDebug里面提供的数据，结果跑出来和它的不一样。可能是它后台的数据太弱了，`以后可能还会看一下是不是我的代码有bug`，尽管提交是AC的。

    时间复杂度：O(N*T)

11. 例题[POJ-2533](https://vjudge.net/problem/POJ-2533#author=0)，AC[源码](./POJ-2533-nlogn.cc)

    题意：求最长单调上升的子序列的长度。经典的LIS问题。

    `题解`：定义dp[i]为从第1个数到第i个数中，以第i个数为结尾的最长上升子序列的长度。

    状态转移为dp[i] = { dp[k] + 1, 1<=k<=i-1,A[k] < A[i]}。这样实现的dp，时间复杂度为O(n^2)，见[N^2实现](./POJ-2533.cc)。接下来我们换种dp的定义。

    反过来定义，我们定义dp[i]为长度为i的子序列，结尾的最小值。因为dp数组保存的是最小值，我们用最大值INF初始化。另外dp[i+1]的值一定比dp[i]的值大，所以显然dp数组是一个单调递增的。我们更新的时候就可以用二分查找更新了。假设输入a, 则更新第一个>=a的值，即std::lower_bound。为什么是更新第一个>=a的值？因为左边是<a的值，他的右边的>=a值，更新左边会使得左边保存的最小值变大，更新右边的话，当然是更新第一个才合理。

    时间复杂度：朴素的实现O(N^2)，优化后O(N*logN)

12. 例题[UVA-437](https://vjudge.net/problem/UVA-437)，AC[源码](./UVA-437.cc)

    题意：给定N种长方体block，每种无限多个，上面的严格小于下面的，问它们最多能堆叠的高度。

    `题解：`把这N种长方体，排成一排，前面的严格大于后面的。这样问题就和LIS问题一模一样了。定义dp\[i][j]为第1种到第i种，第i种长方体为结尾，且第i种长方体的第j条边为高，的最大高度。状态转移为dp\[i][j] =　std::max{ dp\[k][u] , 1<=k<=i-1, 且第i种长方体能够堆叠在第k种长方体上面}。

    另外这题也是经典的DAG例题。定义dp\[i][j]为第i种长方体，它的第j条边为高，从它出发所能获得的最大高度。想象一下，将dp\[i][j]这种状态当成图上的一个节点，图上边的构成便是状态的转移。显然只有长方体能够堆叠在上面才是合法的转移。这就是DAG图上的dp。

    我的代码实现是DAG。当然跑过的节点就记录下来，下次直接返回。这便是记忆化搜索。

    时间复杂度：O(N^2)

13. ------

    小结：可以看出来，目前为止。定义dp的状态一般为，第1种到第i种，什么怎么怎么样。或者定义第i种，什么怎么怎么样。

    另外前i种即第1种到第i种。我喜欢下标从1开始，不过一般书上都是从0开始的。

    如

    定义dp\[i][j]为从顶部向下走，走到第i层j列的最优分数；

    定义dp\[i][j]为第1种物品一直到第i种物品，在选取重量不超过j的情况下，能获得的最大渴望值D。

    对答案进行dp，即定义dp\[i]为组成和为i的2的幂的种数。

    定义dp\[i][j]为从第0秒到第i秒钟，走了j步，能获得的最大苹果数量。

    首先对区间按结束时间从小到大排序，然后定义dp[i]为从第1个时间区间到第i个时间区间，第i个时间区间工作时，能获得的最大效率值。

    定义dp\[i][j]为第1个数到第i个数中，将第i个数排在末尾且将第i个数修改为第j大时，目前为止总共最小的修改量。

    可以直观的定义dp\[i][j]为前i种(第一种1到第i种)，能否组成j。

    现在我们定义dp\[i][j]为前i种硬币，组成和为j时，第i种最多还能剩下多少。如果前i种硬币不能组成和为j，则我们定义dp\[i][j] = -1。

    定义dp\[i][j]为前i种集合，选出j个数组成的组合个数。

    定义dp\[i][j]为在i车站，j时刻时，在路上所等待的总的最少时间。

    定义dp[i]为从第1个数到第i个数中，以第i个数为结尾的最长上升子序列的长度。

    定义dp\[i][j]为第1种到第i种，第i种长方体为结尾，且第i种长方体的第j条边为高，的最大高度。

    定义dp\[i][j]为第i种长方体，它的第j条边为高，从它出发所能获得的最大高度。

14. 例题[HDU-1024](https://vjudge.net/problem/HDU-1024)，AC[源码](./HDU-1024.cc)

    题意：给n个数，将其分为m部分，各部分之间不能有交叉重叠，求m个部分加起来的最大和。

    `题解`：对答案进行dp，即答案求什么，就怎么定义状态。

    定义dp\[i]\[j][0]: 前i个元素构成j组，且最后一组不以第i个元素结尾的最大和; 

    定义dp\[i]\[j][1]: 前i个元素构成j组，且最后一组以第i个元素结尾的最大和;

    则状态的转移只需要考虑第i个元素，选还是不选即可：不选，不以第i个元素结尾，显然前i-1个已经构成了j组；选，即以第i个元素结尾，显然要么加入前面，要么自己单独构成一组。

    另外为什么这样定义的dp的写法，选取的区间是不相交的？因为在状态转移的时候，不存在相交的情况。

    这题我做了几天。网上的题解大多对状态的定义描述的不够清楚。此题也可以这样定义状态：dp\[i][j]表示前i个元素构成j组，且以第i个元素结尾的最大和。状态的转移为：dp\[i][j] = std::max(dp\[i-1][j] + A[i], dp\[k][j-1] + A[i] 1<=k<=i-1)。因为以第i个元素结尾，所以这样定义的状态一定要选第i个元素。显然第i个元素要么加入前面的一组(即dp\[i-1][j])，要么自己单独构成一组(即dp[k][j-1])。

    此外这题必须要滚动数组，不然会超内存。滚动数组的写法和前面的例题(如**例题8**)是一样的，特别需要注意，滚动几次后，滚动数组需要重新初始化。

    时间复杂度:O(N*M)

16. 例题[UVA-12563](https://vjudge.net/problem/UVA-12563)，AC[源码](./UVA-12563.cc)

    题意：给定n个数，问在t时间，你能选择最多的歌曲数量。并且也输出在选择最多歌曲数量的情况下，唱的时间。

    `题解`：定义dp\[i][j]为前i个数，恰好装进容量为j时，能选择的最多的歌曲数量。

    状态转移也是对第i个数，选择和不选择两种情况。背包容量是t-=1，因为要留1秒钟选择耗时678的这首歌曲.

    本题看成把n个数重量为a[i]，价值为1，装进背包容量为t的模型，那么问题就转化为01背包问题了。如果本题你不能轻松的看出是一道01背包问题，那么建议你再去精读**背包九讲**。

    另外本题，我最开始读错题了。我读成，求最多能唱的时间，然后再输出在最多能唱的时间下，输出最多能选择的歌曲数目。

    另外，本题虽然写着t<=1e9，但是题目说了，最多50首歌曲，每首歌曲都不差过３分钟，所有远远达不到1e9的背包容量。

    时间复杂度：O(n*t)

16. 例题[UVA-1347](https://vjudge.net/problem/UVA-1347)，AC[源码](./UVA-1347.cc)

    题意：给你n个点，问你从最左端严格的从左往右走到最右端，再严格从右往左走回来最左端的最短路径长度。

    `题解`:一个人走过去，再走回来。等效于有两个人同时从最左端出发，走到最右端。

    定义dfs(i,j):表示两人同时从第一个点出发，第一个人走到i这个点，第二人走到j这个点，且1到std::max(i,j)都被两人中的一个人走过且只被一个人走过，从这个状态出发走到最右端的最短距离。

    状态转移为：第1个人走到下一个点，或者第2个人走到下一个点。下一个点为std::max(i,j) + 1。

    如果一个人先走到最右端，再走回来。走回来时，需要知道走过去的时候那些点被访问过了，会发现很难表示这样的状态。如果把问题转换为两个人同时从最左端出发，问题变得非常好定义，状态的转移也很显然。

    时间复杂度：O(N^2)

17. 例题[HDU-2191](https://vjudge.net/problem/HDU-2191)，AC[源码](./HDU-2191-correct1.cc)

    题意：给定金额n，和大米的种类m，和每袋大米的价格，重量和袋数。问在给定的金额内买大米所能获得的最大重量。

    `题解`：将给定金额看成背包容量。则问题转换为多重背包问题。

    多重背包问题里，有个物品二进制"拆分"的思想，希望大家明白其原理。

    然后本题，我写了好几天，犯了一个很常见的错误。我也把错误代码放上来，希望大家不要跟我犯相同的错误。另外本题，我提供了3种写法，在熟悉3种写法后，大家选择自己喜欢的一种即可。

    [错误写法](./HDU-2191-error.cc)

    [AC写法1](./HDU-2191-correct1.cc)，朴素二维dp\[i][j]

    [AC写法2](./HDU-2191-correct2.cc)，滚动数组优化

    [AC写法3](./HDU-2191-correct3.cc)，压缩成一维dp[j]

    时间复杂度：O(m*n\*sigm c)

18. 例题[POJ-1014](https://vjudge.net/problem/POJ-1014)，AC[源码](./POJ-1014.cc)

    题意：给定6种弹珠，以及每种弹珠的数量和价值。问能否把他们所有价值的和平分。

    `题解`：设价值的总和为sum。显然如果sum为奇数，则不能平分。把sum/=2看出背包容量(即总重量)，每种弹珠新增一个重量属性，其值和价值一样大，则问题转换为能否恰好填满这个背包。填满时，背包里装的物品的价值和一定等于重量和，因为每种物品价值和重量相等。

    问题便转换为多重背包问题。和上个**例题17**是类似的。

    另外将重量和价值都当作一样，在相关背包问题里是一个常见的技巧。

    时间复杂度：见上个例题

19. 例题[UVA-11400](https://vjudge.net/problem/UVA-11400)，AC[源码](./UVA-11400.cc)

    题意：给定n种物品，每种物品由额定电压,电压源,费用,数量构成，大的额定电压灯泡可以替换小额定电压的灯泡以节约总的费用。问设计这个系统总的最小费用。本题题意不是很好理解，建议多看几遍。
    
    `题解`：参考我在洛谷上针对这题写的一篇[题解](https://www.luogu.org/blog/user36078/solution-uva11400)
    
    个人觉得题目中的"大的额定电压灯泡可以替换小额定电压的灯泡"，在dp过程是连续的一段被替换的，如果能想清楚这点，本题便很简单了。
    
    时间复杂度：O(N^2)
    
20. 例题[UVA-116](https://vjudge.net/problem/UVA-116)，AC[源码](./UVA-116.cc)

    题意：给定一个矩形(m*n)，问从第一列走到第n列的最短路径长度，并输出路径。合法的走法参考原题示意图。

    `题解`：本题和**例题1**没有什么不同。定义sum\[i][j]:从当前位置(i, j)出发，走到最后一列的最小值。状态的转移便是合法的走法。

    不过本题要打印输出路径，所以我的代码还是稍显长了点。如果用递归的方式打印路径，代码长度应该会短一些。可以查看刘汝佳的[写法](https://github.com/OFShare/aoapc-bac2nd/blob/master/ch9/UVa116.cpp)

    时间复杂度：O(m*n)

21. ---

    小结：经过前面20道比较经典的dp题，相信大家对dp已经有初步的认识了。现在可以试着去刷[kuangbin带你飞](https://cn.vjudge.net/article/187) **专题十二 基础DP1**，里面的绝大部分题都可以比较轻松的切了。当然也可以去找其他一些基础dp题如[洛谷普及-dp专题](https://www.luogu.org/problem/list?keyword=dp&difficulty=2&page=1)，巩固，熟悉以及加深对基础dp的理解。

22. 例题[HDU-1074](https://vjudge.net/problem/HDU-1074)，AC[源码](./HDU-1074.cc)

    题意：给定n个作业，每个作业有名字，截止日期，需要的时间。问最少的扣分(定义见题目)，并打印路径(即安排作业的顺序)

    `题解`：一个显然的做法，枚举每一种安排作业的情况，这样的时间复杂度是O(n!)，这样显然是超时。

    我们换种思路，假设只有3门课: A, B, C，另外我们定义dp\[i]\[j]\[k]表示A B C每门课选或没选时的最少扣分情况，则dp\[1]\[1][1]表示A，B，C都完成时的最少扣分，dp\[0]\[1]\[1]则表示A没有完成，B完成，C完成时的最少扣分，然后依次类推。我们再考虑如何转移，比如说当前状态是dp\[1]\[0]\[1]，则它的状态显然只能是dp\[0]\[0]\[1] + 选择A这门课完成，或者dp\[1]\[0]\[0] + 选择C这门课完成，这两种状态转移过来(每次只能一门课一门课的完成)。这样对于任何状态dp\[i]\[j]\[k]都可以由相应的状态转移过来，则答案就是dp\[1]\[1]\[1]，即A完成，B完成，C完成时最少的扣分。

    现在题目里n最多有15门课，则我们可以定义dp\[k1]\[k2]\[k3]\[k4]...\[kn]。但是我们发现，比如说dp\[1]\[1]\[1]，可以压缩成dp[7]，dp\[0]\[1]\[1]可以压缩成dp[3]，这就是我们常说的**状态压缩dp**。

    现在我们可以这样定义dp[i]：整数i对应的集合课程都完成时，所能得到的最少扣分。比如说dp[7]表示A完成，B完成，C完成时的最少扣分，dp[3]表示A没有完成，B完成，C完成时的最少扣分。则答案就是dp\[(1<<n)-1]即都完成时的最少扣分。

    其实这里的状态压缩dp，就是暴力枚举了每门课选或不选的所有状态。

    时间复杂度：O(2^n \* n)

23. 例题[UVA-11584](https://vjudge.net/problem/UVA-11584)，AC[源码](./UVA-11584.cc)

    题意：给定一个字符串，问最少的回文串组数。

    `题解`：一个直观的写法是：定义dp\[i][j]为i到j这个区间里，最少的回文串组数。状态转移为在区间内选一个枚举点k，即dp\[i][j] 由 dp\[i][k] + dp\[k+1][j]构成，答案便是dp\[1][n]，不过这样时间复杂度为O(n^3)，显然会超时。[超时代码](./UVA-11584-TimeLimitExceeded.cc)

    接着我们可以换种定义把区间的起点固定在最开始，减少一维，即定义dp[i]为前i个字符，组成的最少回文串组数。状态转移为dp\[i] = dp[j] + (j+1, i)是否是回文串。这样便可以顺利通过本题了。

    时间复杂度：O(n^3)，优化后O(n^2)

24. 例题[UVA-10003](https://vjudge.net/problem/UVA-10003)，AC[源码](./UVA-10003.cc)

    题意：给一个长棍，有n个切点，问最少的费用。费用的定义见原题。

    `题解`：一个直观的写法是枚举每一种切法，即全排列，所以时间复杂度为O(n!)，显然超时。

    我们换种想法，定义dp\[i][j]为i到j这个区间里的最少费用，则可以枚举区间里的点k，这样就可以通过本题了。

    这题的写法和**例题23**的超时写法是类似的，不过本题n是50，所以O(n^3)也没问题。这类dp就是大家常说的**区间dp**。

    另外在区间里枚举点时，要注意是 { dp\[i][k]，dp\[k][j] } 还是{ dp\[i][k]，dp\[k+1][j]}即区间的划分；以及{ k =i }还是 { k = i+1 }即枚举点k的起始点位置；最后还要注意区间划分递归的边界，是{ i ==j } 还是 {j -i == 1}。

    时间复杂度：O(n^3)

25. 例题[P2679](https://www.luogu.org/problem/P2679)，AC[源码](./P2679.cc)

    题意：给定字符串A，字符串B，问从字符串A中取出k个互不重叠的非空子串，拼接成字符串B的方案数。

    `题解`：看到求方案数，我们第一时间想到dp。下面是状态的定义

    dp\[i]\[j]\[k]\[0]: 字符串A的前i个元素，选出k个不重叠子串，不选A的第i个字符，匹配了前j个字符串B，的方案数

    dp\[i]\[j]\[k]\[1]: 字符串A的前i个元素，选出k个不重叠子串，选A的第i个字符，匹配了前j个字符串B，的方案数

    状态的转移就是对第i个字符选和不选情况的转移(是不是和前面的好多例题类似)，细节见AC源码。

    另外本题我卡了好几天才调过去的，卡的原因是数组越界了(未定义行为)，但是程序没挂，导致我一直没发现这个问题。[详细过程看着](https://www.luogu.org/discuss/show/142210)

    时间复杂度：O(n\*m\*k)

26. 例题[P1734](https://www.luogu.org/problem/P1734)，AC[源码](./P1734.cc)

    题意：选取和不超过S的若干个不同的正整数，使得所有数的约数（不含它本身）之和最大。

    `题解`：选取和不超过S的若干个不同的正整数，把S看出背包容量，那么就是装进背包容量不超过S的01背包问题了，价值就是被选进装入背包里的那个数字的约数和。答案便是dp\[S]\[S]

    最开始我也没有看出这就是一道01背包裸题，QAQ。

    时间复杂度：O(S * S)

27. 例题[P1244](https://www.luogu.org/problem/P1244)，AC[源码](./P1244.cc)

    题意：略，见原题

    `题解`：见[题解 P1244 【青蛙过河】](https://www.luogu.org/blog/user36078/solution-p1244)

    这题有点像汉诺塔，代码虽然很短，但是一步步分析状态的转移还是非常有意思的。

    时间复杂度：O(h)

28. 例题[P1115](https://www.luogu.org/problem/P1115)，AC[源码](./P1115.cc)

    题意：给出一段序列，选出其中连续且非空的一段使得这段和最大。

    `题解`：经典的求最大的连续的子段和问题。定义dp[i]为：前i个元素，且以第i个元素结尾的最大的连续子段和。

    状态的转移便是第i个元素要么单独构成一组，要么和前面的组合成一组。其实这样的状态转移，我们在前面的例题中是不是已经遇到过很多次了。答案便是std::max{dp[1], dp[2], ..., dp[n]}。

    时间复杂度：O(N)

29. 例题[P1719](https://www.luogu.org/problem/P1719)，AC[源码](./P1719-solution2.cc)

    题意：求最大子矩阵。

    `题解`：这也是经典的例题。首先我们非常容易暴力的想到一个枚举所有子矩形的办法。枚举策略是，枚举子矩形左上角的点，以及它的宽度和高度。便于处理，会预先处理出一个二维前缀和。

    这个最显然的做法是O(N^4)的，[参考代码](./P1719.cc)

    接着我们继续优化，用一个叫做矩阵压缩的策略。

    矩阵压缩可以参考链接里的第一篇题解[矩阵压缩](https://www.luogu.org/problemnew/solution/P1719)，其实就是每一列求和，按列压缩。

    这样我们枚举上下界，假设为i和j，那么我们便把第i行到第j行的，每一列都压缩，然后对压缩后的数组求连续的最大字段和即可。最大字段和的做法就是**例题28**。

    枚举上下界O(N^2)，最大子段和O(N)，总的时间复杂度便是O(N^3)。

    其实O(N^3)的做法也是枚举了所有的子矩阵，但是枚举的策略不同，导致了时间复杂度的不同。

    时间复杂度：O(N^4)，优化后O(N^3)

30. 例题[P1481](https://www.luogu.org/problem/P1481)，AC[源码](./P1481.cc)

    题意：给n个字符串，问能够组成的最长的词链。

    `题解`：这题其实和经典的LIS**例题11**O(N^2)的写法本质上是一样的。定义dp[i]为前i个字符串能组成的最长的词链，状态的转移为dp[i] = std::max{dp[i], dp[j] + 1第j个字符串是第i个字符串的前缀 1 <= j < i}。

    时间复杂度：O(N^2)

31. 例题[P1564](https://www.luogu.org/problem/P1564)，AC[源码](./P1564-solution2.cc)

    题意：N位同学排成一排，老师只会把连续一段的同学分进一个机房。老师想知道，至少需要多少个机房。能进一个机房的条件是，要么保证整个机房都是同一位神牛的膜拜者，或者两个神牛的膜拜者人数差不超过M。

    `题解`：定义dp[i]为前i个同学至少需要的机房数。状态的转移为dp[i] = std::min(dp[i], dp[j] + 1，j + 1 ~ i 能够排进一个机房 0 <= j < i)。

    最开始这题我也没想出来。现在一看其实和**例题30**的写法是类似的，但是本题会稍难点，因为状态的转移不如上题那么显然。本题状态的转移便是题目所说的能够进一个机房时的情况。

    另外本题判断j + 1 ~ i 是否都是同一位神牛的膜拜者，或者两个神牛的膜拜者人数差不超过M。可以使用'差分前缀和'预处理后只需要O(1)的时间判断。如果直接暴力判断j + 1 ~ i那么需要O(N)，总的时间复杂度便是O(N^3)，这样便超时了。[超时代码](./P1564.cc)

    时间复杂度：O(N^3)，优化后O(N^2)

32. 例题[P1387](https://www.luogu.org/problem/P1387)，AC[源码](./P1387.cc)

    题意：在一个n * m的只包含0和1的矩阵里找出一个不包含0的最大正方形，输出边长。

    `题解`：最直接的想法是枚举所有正方形，枚举左上角的坐标(x, y)，以及边长width。这样的时间复杂度是O(N^3)的。我们还可以做的更优。

    定义dp\[i]\[j]为: 当正方形右下角坐标为(i, j)时，不包含0时能构成的最大正方形的边长。

    大家在脑子里或用笔画一下，状态的转移为dp\[i][j] = std::min(dp\[i - 1]\[j -1]，dp\[i]\[j - 1]，dp\[i - 1]\[j]} + 1。

    这样我们就可以遍历一遍整个矩阵就行了。

    时间复杂度：O(N^3)，优化后O(N^2)

33. 例题[P1681](https://www.luogu.org/problem/P1681)，AC[源码](./P1681.cc)

    题意：找到面积最大的且内部是黑白交错（即两个相连的正方形颜色不能相同）的正方形的最长边长。

    `题解`：此题和**例题32**十分类似，上个题会做，这题也变的简单了。

    定义dp\[i]\[j]\[0]为: 当在右下角坐标为(i, j)时，坐标(i, j)的值为0时能构成的最大交错正方形的边长。

    定义dp\[i]\[j]\[1]为: 当在右下角坐标为(i, j)时，坐标(i, j)的值为1时能构成的最大交错正方形的边长。

    状态的转移就是满足题目所说的交错的条件。

    时间复杂度：O(N^2)

34. ---

    小结：

    **例题29**，**例题32**，**例题33**都是关于坐标的dp，我们把这种dp叫做，**坐标dp**。

    另外前面我们做了这么多题，逐渐发现状态的转移一般才是问题的难点。不过随着大家做题越来越多，很多状态的转移也是很显然的。而且我们可以看到，很多dp题都是类似的，希望大家多用类比的方式思考。

35. 例题[P2426](https://www.luogu.org/problem/P2426)，AC[源码](./P2426.cc)

    题意：给定n个排成一排的数字，每次我们可以从左端点删数，也可以从右端点删数。删数操作能获得一定价值，问删除所有数，能获得的最大价值。

    `题解`：定义dp\[i]\[j]为: 删除i~j, 能得到的操作最大价值。状态转移就是枚举分割点，删左端点即i ~ k, 或右端点即k ~ j。

    其实好多题目里的条件，就指明了动态方程里状态是如何转移的。

    时间复杂度：O(N^3)

36. 例题[P1435](https://www.luogu.org/problem/P1435)，AC[源码](./P1435.cc)

    题意：给定一个字符串，问将它变成回文串时，最少的插入字符的个数。字符插入的位置不限。

    `题解`：定义dp\[i][j]为: i~j之间(含i, j)变成回文词最少的插入数。

    状态转移分3种，当A[i] == A[j]时，那么dp\[i]\[j] = dp\[i - 1]\[j - 1]。

    当A[i] != A[j]是，我们在脑子里想象一下，我们可以在 i 的左边插入一个字符和A[j]相等，用代码表示即dp\[i]\[j] = dp\[i]\[j - 1] + 1。同理我们也可以在j的右边插入一个字符和A[i]相等，即dp\[i]\[j] = dp\[i + 1]\[j] + 1。

    本题我最开始也没想出来，现在来看其实状态的转移也是很明显的，就是题目插入字符的条件。

    另外本题还有另外一种做法：将给定的字符串倒过来，求和原字符串的最长公共子序列长度LCS，然后原字符串的长度 - LCS便是答案。 

    本题和**例题35**十分类似，只是状态的转移不同而已，它们都属于**区间dp**。

    时间复杂度：O(N^2)

37. 例题[P2623](https://www.luogu.org/problem/P2623)，AC[源码](./P2623.cc)

    题意：有n个背包，分为甲乙丙三类，甲背包是给定一个体积然后通过一个函数算出对应的价值。乙是多重背包，丙是完全背包。问装进背包容量为m能获得的最大价值。

    `题解`：就是3种混合的背包。对于甲类物品，当在更新dp\[i]\[j]时，可以枚举分给甲物品的体积for(int k = 0; k <= j; ++k)。乙和丙就是常见的背包类型。

    这题我写完后，调了很久，竟然是在更新dp\[i]\[j]的时候忘记取std::max了。

    时间复杂度：O(n * m * log(乙背包的个数))

38. 例题[P1853](https://www.luogu.org/problem/P1853)，AC[源码](./P1853-solution2.cc)

    题意：最开始你有一个资产，每年可以投资d种债券，获得的利息加上本金，也可以继续投资下一年。问投资n年，总资产的最大值。

    `题解`：每一年都要根据自己手头上的钱来选择买哪种债券，选择的话就直接是**完全背包**，因为每种债券可以买无限多张。

    背包容量就是你每一年开始的资产。但是背包容量会变大，因为这一年获得的利息加上本金构成下一年的背包容量。

    另外本题有点卡常，我用滚动数组的写法竟然还是Tle了一个点，写法见这[滚动数组TLE代码](./P1853.cc)，压缩成一维的dp才可以通过。

    这题最开始我也没有看出来是个完全背包的模板题，看来背包问题真的是有许多变化，希望大家在做题的过程中慢慢体会。

    时间复杂度：O(s * n * d)

39. [例题UVA-1625](https://vjudge.net/problem/UVA-1625), AC[源码](./UVA-1625.cc)

    题意: 两个颜色序列，将他们合并，合并的时候，每次都从开头拿颜色，对于每一个颜色c来说，都有他的跨度l(c)，就是最后的位置与最前的位置的差值，就怎样的排列是的所有l(c)总和最小.

    `题解`: 这题我陆续写了3个晚上, 也看了网上的大部分题解, 如[这篇](https://blog.csdn.net/ltrbless/article/details/98487740), 但是他们定义的dp状态都是描述不准确的. 如我贴出来的这篇, 他是这样定义的: 当前的状态 dp\[ i ]\[ j ] 代表 a 串使用了前 i 个， b 串使用了前  j 个的最小总的距离. 这个状态是错误的, 如a串为AAE, b串为BBF, 那么按照他的定义dp\[1][1]为0. 除了状态描述有问题, 他的其他描述都是ok的.这里的状态定义描述应该为: dp\[i]\[j]: 表示前i个字符串A, 和前j个字符串B合并后**对答案的最小贡献**. 什么叫对答案的最小贡献? 其实就是答案应该是A, B串合并完后才能知道最后的答案, 中途计算的都是对答案的贡献, 如上面的例子: a串为AAE, b串为BBF, 那么dp\[1][1]为2, 合并的串为AB或BA(并不关心相对位置), 还剩下AE + BF字符串. **即考虑每种字母对答案的贡献，且一定是它的第一个出现的位置到最后一个出现的位置那一段区间都有贡献 **

    转移便是: dp\[i]\[j]由dp\[i - 1]\[j], 或者dp\[i]\[j - 1]转移而来.

    我的实现是O(N ^ 2 * 26), 因为要枚举26种字符, 所有复杂度会多乘一个26, 但是这部分有可以O(1)实现, 具体做法就是: 定义cnt\[i]\[j]: 表示前i个字符串A, 和前j个字符串B合并后有多少种字符是'已经开始但尚未结束'. 数组cnt也可以通过dp求得. 这里我就不实现了.

    时间复杂度: O(N ^ 2 * 26), 优化后O(N ^ 2 * 1)

40. 例题[UVA-1626](https://vjudge.net/problem/UVA-1626), AC[源码](./UVA-1626.cc)

    题意: 给定一个字符串, 把它变成合法的字符串, 最少需要添加的字符数, 打印出来.

    `题解`: dp\[i]\[j]: 表示i到j这个区间构成规则的序列最少需要添加的字符个数, 枚举k. **区间dp**

    注意本题有空行, 所以不能用scanf(). 可以用fgets()读取一行, 再用sscanf(). 

    打印解, 可以用递归.

    时间复杂度: O(N ^ 3)

41. 例题[UVA-1331](https://vjudge.net/problem/UVA-1331), AC[源码](./UVA-1331.cc)

    题意: 问三角剖分, 最大的三角形最小是多少.

    `题解`: 这类三角剖分有关的题, 状态的定义都是类似的. 

    dp\[i]\[j]: 表示从i, i + 1, i + 2, ... , j,(看成一个圈, j的下一个元素为i, 即i和j相邻), 这些顶点中所剖分的三角形中, 最大三角形面积的最小值. 枚举k. 和上一道类似, 也是**区间dp**

    枚举的时候, 如果判断顶点i, 顶点j, 和顶点k组成的三角形内部没有其他顶点? 如果内部有顶点, 则三角形被划分成了3部分, 判断这3部分相加是否等于原三角形. 算三角形的面积可以用**叉积** a(x1, y1) * b(x2, y2) = x1 * y2 - y1 * x2, 取绝对值是四边形的面积, 再除以2便是三角形的面积了.

    时间复杂度: O(N ^ 3)

42. 例题[P1736](https://www.luogu.org/problem/P1736), AC[源码](./P1736.cc)

    题意: 求最大的对角线正方形的边长.

    `题解`: 注意要分两种情况, 类似于字母'X'.

    dp\[i]\[j]: 右下角坐标为(i, j)的最大答案(即猫猫一口下去可以吃掉的鱼的数量)的长度

    up\[i]\[j]: 坐标为(i, j)向上都为0的最大的长度

    left\[i]\[j]: 坐标为(i, j)向左都为0的最大的长度.

    转移方程: 

    dp\[i]\[j] = std::min(dp\[i - 1]\[j - 1], up\[i]\[j], left\[i]\[j]);

    up\[i][j] = up\[i - 1]\[j] + 1

    left\[i]\[j] = left\[i]\[j - 1] + 1

    在遍历的时候, 同时更新这3个dp方程.

    超内存的[代码](./P1736-MLE.cc), 复用原来的数组就可以避免超内存了.

    时间复杂度: O(N ^ 2)

43. 树上的dp, 即**树形dp**. 常见的有**树的最大独立集**, **树的重心**, **树的最远点对**.

    下面分别给出几道常见的例题, 以熟悉基本的树形dp.

44. 例题[POJ-2342](https://vjudge.net/problem/POJ-2342), AC[源码](./POJ-2342.cc)

    题意: 员工和boss构成一个树的结构, 每个人都有一个开心值(即题目所说的conviviality), 员工和boss不能都去参加, 问最大的开心值. 

    `题解`: 经典的**树的最大独立集**问题. 

    定义dfs(rt, is_choose): 以结点rt为根的子树, 选择/不选rt时, 能获得的最大独立点集(即题目所说的guests' conviviality ratings).

    转移: 选了结点rt, 那么它的儿子结点都不选. 没选结点rt, 那么它的儿子结点都可以选或者不选.

    这种树上的dp, 一般用记忆化实现. 当考虑当前结点rt时, 它的儿子结点的信息都是已经知道的(递归回溯回来).

    时间复杂度: O(N)

45. 例题[UVA-12186](https://vjudge.net/problem/UVA-12186), AC[源码](./UVA-12186.cc)

    题意: 给定一个树的结构, 叶子结点可以发起请愿书(即题目所说的petition), 每个boss(即非叶子结点)只有当有>= T%的儿子结点都发起请愿书时, 他才向上发起请愿书. 问根结点也发起请愿书时, 最少有多少位叶子结点发起了请愿书.

    `题解`: 定义dfs(rt)为: 以结点src作为根的子树, 结点src向上发起请愿书最少需要多个工人.

    状态的转移: 考虑结点rt时, 如果他也要向上发起请愿书,那么至少得有>= T%的儿子结点都发起了请愿书, 那么肯定是考虑工人少的儿子结点. std::sort排个序即可.

    时间复杂度: 因为要排序, 所以是O(n * log n) 

46. 例题[UVA-1220](https://vjudge.net/problem/UVA-1220), AC[源码](./UVA-1220.cc)

    题意: 参加一个party, 员工和boss不能同时参加. 员工和boss构成一个树的结构, 问最多参加的人数, 以及在最多参加的人数下, 方案是否唯一.

    `题解`: 也是一道经典的**数的最大独立集**问题, 和**例题44**基本一样, 但是多了一个是否唯一性. 我们同理也可以增加新的数组来维护这个信息. 即定义unique\[i]\[0]: 不选结点i. unique\[i]\[1]: 选结点i. 在获得最大值的前提下, 是否唯一.

    是否唯一的转移方程: 

    选择结点rt, 只要有一个儿子结点不唯一, 则结点rt也不唯一.

    不选择结点rt, 不选和选相等, 则不唯一. 以及较大的那个不唯一, 则结点rt也不唯一

    输入的是字符串(题目中的name), 用的std::map<std::stirng, int> 每个人名对应一个编号

    时间复杂度: O(N)

47. 例题[POJ-1655](https://vjudge.net/problem/POJ-1655), AC[源码](./POJ-1655.cc)

    题意: **求树的重心**.

    `题解`: 我们分析树上的一个结点rt, 删除结点rt, 那么分为2部分, 结点rt的儿子结点和它上方的结点.

    定义dfs(rt)以结点rt为根的子树所含有的结点个数. 在dfs(rt)回溯后, 结点rt的情况都是知道的.这样可以方便的计算删除结点rt时, 产生的最大的子树, 然后和答案取max.

    时间复杂度: O(N)

48. 例题[POJ-3107](https://vjudge.net/problem/POJ-3107), AC[源码](./POJ-3107.cc)

    题意: 求树的重心, 并输出.

    `题解`: 和上一个题一样, 但是在POJ上, 用vector存图的方式TLE[见这](./POJ-3107-tle.cc)了, 改为**链式前向星**存图才过的. 估计是POJ的编译器太老旧了, 对vector没有什么编译优化. 另外本题// 递归的边界, 也要更新A[rt]. 调试了很久才发现这个问题.  

    时间复杂度: O(N)

49. 例题[51Nod-2602](https://vjudge.net/problem/51Nod-2602), AC[源码](./51Nod-2602-dfs.cc)

    题意: **求树的直径**

    `题解`: 有两种经典的求法.

    第一种: 任选树上的一个结点, dfs走到最远的一个结点记为u, 再从结点u dfs一次走到最远的一个结点记为v, 那么u-v便是树的直径. [实现一](./51Nod-2602-dfs.cc)

    第二种: dfs(i): 记录的是以结点rt为根的子树, 根到叶子最深的长度. 那么经过结点rt(它是子树的根, 所以路径只能是从儿子考虑)的最长路径便是结点的儿子结点最长 + 次长, 再对所有结点取max便是树的直径. [实现二](./51Nod-2602.cc)

    时间复杂度: O(N)

50. 例题[HDU-2196](https://vjudge.net/problem/HDU-2196), AC[源码](./HDU-2196.cc)

    题意: 求树上每个点的最远距离.

    `题解`: 跑**Floyd**时间复杂度O(N ^ 3); 对每个点跑dfs求最远距离O(N ^ 2); 另外还有2种时间复杂度O(N)的解法, 下面分别分析之. 

    O(N)方式一: 先求出树的直径u-v, 然后从u和v分别dfs记录它们到其他结点的最远结点, 便是答案. 为什么这样做是可以的, 因为树上的每个点的最远距离, 最后到达的终点一定是**树的直径**的两个端点之一. [实现一](./HDU-2196.cc)

    O(N)方式二: 对于每个结点的最远距离, 要么向下走, 要么向上走. [实现二](./HDU-2196-dp.cc)

    可以参考这篇[题解](https://111qqz.com/2016/07/hdu2196/)

    向上走时, dfs其实是从根向叶子结点更新. 

    向下走时其实是叶子向根更新(回溯的时候).

    时间复杂度: O(N)

51. 例题[UVA-1218](https://vjudge.net/problem/UVA-1218), AC[源码](./UVA-1218.cc)

    题意: 给定一颗树, 每个结点要么是服务器要么是客户端, 不过与客户端相邻的结点有且只有一个服务器. 问最少的服务器结点.

    `题解`: 参考我为洛谷写的这篇[题解](https://www.luogu.org/blog/user36078/solution-uva1218)

    时间复杂度: O(N)

52. 例题[POJ-2184](https://vjudge.net/problem/POJ-2184), AC[源码](./POJ-2184.cc)

    题意: 一群奶牛，给出每头的smartness和funness;，范围是-1000到1000。选出一批奶牛，使得它们的smartness和funness和都非负。求smartness和 加 funness和的最大值。

    题解: 本题有两种做法, 一种是dp, 一种是搜索剪枝.

    解法一搜索剪枝: 对于每头奶牛有选和不选两种方式, 所以时间复杂度为O(2 ^ N). 我们加上剪枝, 对于搜索到第i种奶牛时, 判断剩下的smartness + funness > 0 的最大和, 加上当前的smartness + funness如果还是没有超过已经搜索到的最优解, 就不从该状态继续往下搜索了, 即剪枝. 参考[代码](./POJ-2184.cc)

    解法二动态规划: 我们按照背包的思路去做, 可以把smartness当作重量, funness当作价值. 那么我们可以定义dp\[i]\[j]: 前i种物品, **恰**好装进背包容量为j时, 能获得的最大的smartness + funness的最大值. 注意我们题目要求的是两者和的最大值，而不是funness的最大值. 

    所以我们不能这样定义状态dp\[i]\[j]: 前i种物品, **恰**好装进背包容量为j时, 能获得的最大的价值。这里会把最大的价值当作funness，而我们是最大化两者的和. 由于有负数，所以可以每个smartness+1000，然后开一个数组记录用该体积得到最大值时用了多少个1000. 还得滚动数组, 不然超内存了. 参考[代码](./POJ-2184-dp.cc )

    时间复杂度: 略

53. 例题[POJ-1631](https://vjudge.net/problem/POJ-1631), AC[源码](./POJ-1631.cc)

    题意: 求最长上升子序列.

    题解: 定义dp[i]为以第i个元素结尾的最长上升子序列的长度, 这样的定义的状态, 实现起来, 时间复杂度为O(N ^ 2). 我们换种定义. dp[i]为长度为i的子序列的结尾最小的值. 这样dp数组是单调递升的, 因为长度更长的子序列, 结尾的数字也更大. 状态转移为找到第一个大于等于当前数的数, 然后更新它. 状态转移可以二分实现. 所以时间复杂度为: O(N * log N)

    时间复杂度: 朴素O(N ^ 2), 优化后O(N * log N)

54. 例题[POJ-1664](https://vjudge.net/problem/POJ-1664), AC[源码](./POJ-1664.cc)

    题意: 把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。

    题解: 经典的**划分数**问题. 定义dp\[i][j]为将i个同样的苹果放进最多j个盘子的分法. 

    状态转移可以分: 有空盘子和无空盘子来考虑.

    有空盘子, 则选择一个盘子不放. 如果有个盘子不放, 则为dp\[i][j - 1] (有个盘子不放的话, 还是有i个苹果, 但是盘子少一个). 

    无空盘子, 则每个盘子都拿掉一个苹果是一种分法, 即dp\[i - j]\[j].(有j个盘子, 每个拿掉一个还剩下i - j个, 盘子还是有j个)

    所以dp\[i]\[j] = dp\[i - j]\[j] + dp\[i]\[j - 1]. 递归的边界为 i == 0, 或j == 1, 都是只有一种分法, 返回1.

    时间复杂度: O(M * N)

55. 例题[POJ-2392](https://vjudge.net/problem/POJ-2392), AC[源码](./POJ-2392.cc)

    题意: 给出多种砖，属性包含高度、数量、高度阈值。求可以垒出的最大高度。

    题解: 我们先手玩样例, 很容易发现, 应该按照阈值从小到大排序. 然后就是常见的**多重部分和问题**, 这也是一种背包问题. 定义dp\[i]\[j]为, 前i种物品, **恰好**装进背包容量为j时, 第i种物品最多还能剩下多少件. 如果这种状态不存在我们可以定义它为-1.

    状态转移为, 如果上一种物品已经能够恰好装满j, 那么最多剩下就是第i种物品原始的数量. 如果dp\[i][j - Height_i] >= 1, 这里和背包里的**加选一件物品**的概念类似, 是难点, 但是一旦你理解它了, 就会发现是如此的自然简单. 我们可以这样理解, 我们在更新dp\[i]\[j]时, dp\[i]\[j - Height_i]一定是已经被更新好了的, 因为我们的j是从小到大的. 那么dp\[i]\[j - Height_i]的含义就是前i种物品**恰好**放进背包容量为j - Height_i时, 第i种物品最多剩下的数量, 可能为0, 1, 2, 3, 4, 5, a[i]这些值, 如果我们再选一件第i种物品, 加上选的物品的高度, 是不是就转移到了dp\[i]\[j] . 我们选了一件, 自然就减去一, 所以此时dp\[i]\[j] = dp\[i][j - Height_i] - 1. 这就是背包里**加选一件物品**的意思. 其它状态dp\[i]\[j]不存在, 赋值为-1.

    时间复杂度: O(N *最大背包容量)

    ---

    小结: 例题55, 例题53等这类dp, 题目所求的答案, 都是在dp数组的**下标里**(即大家口中说的**改变dp的对象**), 而不是常见的dp数组本身. 

56. 例题[HDU-1160](https://vjudge.net/problem/HDU-1160), AC[源码](./HDU-1160.cc)

    排序后dp

57. 例题[HDU-1078](https://vjudge.net/problem/HDU-1078), AC[源码](./HDU-1078.cc)

    记忆化搜索

58. 例题[HDU-1257](https://vjudge.net/problem/HDU-1257), AC[源码](./HDU-1257.cc)

    最长上升子序列

59. 例题[HDU-1260](https://vjudge.net/problem/HDU-1260), AC[源码](./HDU-1260.cc)

    从前往后决策dp

60. 例题[HDU-2859](https://vjudge.net/problem/HDU-2859), AC[源码](./HDU-2859.cc)

    坐标类dp

61. 例题[POJ-1015](https://vjudge.net/problem/POJ-1015), AC[源码](./POJ-1015.cc)

    背包类dp, 较难. dp数组下标有负数时, 偏移量技巧

62. 例题[POJ-1065](https://vjudge.net/problem/POJ-1065), AC[源码](./POJ-1065.cc)

63. 例题[POJ-1458](https://vjudge.net/problem/POJ-1458), AC[源码](./POJ-1458.cc)

    最长公共子序列

64. 例题[POJ-1661](https://vjudge.net/problem/POJ-1661), AC[源码](./POJ-1661.cc)

    看起来很难, 从到达的终点开始dp回去

65. 例题[POJ-3181](https://vjudge.net/problem/POJ-3181), AC[源码](./POJ-3181.cc)

66. 例题[POJ-3186](https://vjudge.net/problem/POJ-3186), AC[源码](./POJ-3186.cc)

    一开始写的dp, [tle](./POJ-3186-tle.cc). 然后优化, 发现k不需要保存, 可由i和j推算出来.

67. 例题[POJ-3280](https://vjudge.net/problem/POJ-3280), AC[源码](./POJ-3280.cc)

68. 例题[POJ-3783](https://vjudge.net/problem/POJ-3783), AC[源码](./POJ-3783.cc)

    经典的鸡蛋下落问题

69. 例题[UVA-10934](https://vjudge.net/problem/UVA-10934), AC[源码](./UVA-10934.cc)

    本题是上个例题的**加强版**, 最开始我看了紫书上的题解, 紫书上状态是这么定义的: 用状态d(i,j)表示用i个球实验j次所能测试的楼的最高层数。

    这个状态的定义没有与小球硬度相关的信息, 其实是不太准确的, 需要自己脑补一些东西. 我大概思考了很久, 才明白了其中的奥秘, 我个人觉得状态应该是这样描述才对: 用状态d(i,j)表示用i个球实验j次, 在最坏情况下能够确定小球硬度时, 所能测试的楼的最高层数。

    下面我来推倒一下转移方程, 书上写的实在是太简单了, 其实问题一点都不简单呀.

    首先, 我们应该会做**上一个例题68**, 我们根据上一个例题的状态来思考.

    f(i, x) = j, 表示有i个小球, 最高有x层楼, 可以在j次实验下确定小球的硬度. 如果有x + 1层楼, 那么在j 次实验下是不能确定小球的硬度的, 这就是最高有x层楼的意思.  这个也可以表示为d(i, j) = x, (**1式**) 交换一下, 换个函数d.

    考虑决策: 我们在第k层楼丟小球做实验, 后面会把k消掉. 有碎和不碎两种

    碎: f(i - 1, k - 1) = j - 1 ======> d(i - 1, j - 1) = k - 1   (**2式**)

    不碎: f(i, x - k) = j - 1   ======> d(i, j - 1)      = x - k    (**3式**)

    联立上面的3个式子, 可以得到d(i, j) = d(i, j - 1) + d(i - 1, j - 1) + 1.

    边界条件为: F(0, x) = 0, F(x, 0) = 0

    这种dp, 其实我们也见过, 就是前面提到的**换个对象dp**的思想, 答案在数组的下标里

70. 例题[UVA-1252](https://vjudge.net/problem/UVA-1252), AC[源码](./UVA-1252.cc)

    题意非常难读懂, 较难. 是一道状态压缩的dp题. 涉及到最优决策, 所以枚举决策, 然后转移.

71. 
