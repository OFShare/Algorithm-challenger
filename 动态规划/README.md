##### 动态规划讲解

精选了一些dp例题，每道例题都给出ac代码，并详细讲解。量不在多，而在精。

---

1. 例题[POJ-3176](https://vjudge.net/problem/POJ-3176) ，AC[源码](./POJ-3176.cc)

   题意：给一个数字三角形，问从top走到底部能获得的最大分数是多少？只能沿着两对角线向下走。

   题解：定义dp\[i][j]为从顶部想下走，走到第i层j列的最优分数。一层一层的往下走，每一层记录所有可能的值，然后去更新下一层，最后对底部所有可能的值取max就是最终的答案。

   时间复杂度：O(n^2)

2. 例题[POJ-3624](https://vjudge.net/problem/POJ-3624) ，AC[源码](./POJ-3624)

   题意：给定N个小饰品，每个小饰品有重量W和渴望值D且最多选一个，问不超过重量M的情况下，最大的D是多少？

   题解：定义dp\[i][j]为第1种物品一直到第i种物品，在选取重量不超过j的情况下，能获得的最大渴望值D。想象下把N种物品排成一行：第1种物品，第2种物品，第3种物品，. . . ，直到第N种物品。一层一层的往右边走，每一层记录所有可能的值，然后去更新下一层，最后答案为dp\[n][M]。

   源码实现用了滚动数组，利用了奇偶性，防止一些题会被内存卡掉。阅读代码时去掉"&1"的操作，就是正常空间大小的dp实现。
   
   这题就是大家常说的经典01背包问题模板题。
   
   时间复杂度：O(N*M)
   
3. 例题[POJ-2229](https://vjudge.net/problem/POJ-2229)， AC[源码](./POJ-2229)

   题意：给定一个数字N，问由2的幂组成的和为N的由多少种。2的幂从小到大排序，即不重复计数。

   题解：对答案进行dp，即定义dp\[i]为组成和为i的2的幂的种数。想象下，把1 2 3 4 5 . . . 排成一排，dp\[i]去更新dp\[i+1]和dp\[2*i]。答案便是dp\[N]。

   为什么是这样更新，看下面的1和2的等式。

   1 = 2^0

   2 = 2^0 + 2^0

   2 = 2^1

   一开始我写了[暴力枚举](./POJ-2229-timeout.cc)每种组合情况，这应该是一般人都会想到的做法，但显然会超时。另外看到数据范围是(1 <= N <= 1,000,000)，如果想到是dp的话，应该能猜到是一维的dp即对答案dp，这样时间复杂度才满足要求。

   时间复杂度：O(N)

4. ---

   小结：可以看到前3题都是类似的dp，一层一层的走，都是用一个已经更新好的状态(即从出发走到当前的最优状态)去更新这个状态能转移到的其他状态。能转移到的状态可能是接下来的一层如例题1，也可能是跳了几层如例题3，第i层去更新第2*i层。因为每一层都是从出发走到当前的最优值，这样层层更新下去，得到的结果一定是最优的。

   还有其他更新dp的方式，如有一个dp方程式dp[i] = dp[i-1] + dp[i-2]，这样的dp是dp[i]这个状态由dp[i-1]和dp[i-2]这两个状态组成/更新。

   例题1 2 3，我的dp实现方式都是用某个状态去更新它能转移到的状态。本质上这两张方法都是一样的。

   希望大家用类比的方式思考，理解。

   

   

   

   

   









