##### 动态规划讲解

精选了一些dp例题，每道例题都给出ac代码，并详细讲解。量不在多，而在精。

TODO [kuangbin带你飞](https://cn.vjudge.net/article/187) **专题十二 基础DP1**

TODO [紫书](https://github.com/OFShare/aoapc-bac2nd/tree/master/ch9) **第九章 动态规划例题**

TODO [背包九讲](https://github.com/OFShare/pack) 

---

1. 例题[POJ-3176](https://vjudge.net/problem/POJ-3176) ，AC[源码](./POJ-3176.cc)

   题意：给一个数字三角形，问从top走到底部能获得的最大分数是多少？只能沿着两对角线向下走。

   `题解`：定义dp\[i][j]为从顶部向下走，走到第i层j列的最优分数。一层一层的往下走，每一层记录所有可能的值，然后去更新下一层，最后对底部所有可能的值取max就是最终的答案。

   时间复杂度：O(n^2)

2. 例题[POJ-3624](https://vjudge.net/problem/POJ-3624) ，AC[源码](./POJ-3624.cc)

   题意：给定N个小饰品，每个小饰品有重量W和渴望值D且最多选一个，问不超过重量M的情况下，最大的D是多少？

   `题解`：定义dp\[i][j]为第1种物品一直到第i种物品，在选取重量不超过j的情况下，能获得的最大渴望值D。想象下把N种物品排成一行：第1种物品，第2种物品，第3种物品，. . . ，直到第N种物品。一层一层的往右边走，每一层记录所有可能的值，然后去更新下一层，最后答案为dp\[n][M]。

   源码实现用了滚动数组，利用了奇偶性，防止一些题会被内存卡掉。阅读代码时去掉"&1"的操作，就是正常空间大小的dp实现。
   
   这题就是大家常说的经典01背包问题模板题。
   
   时间复杂度：O(N*M)
   
3. 例题[POJ-2229](https://vjudge.net/problem/POJ-2229)， AC[源码](./POJ-2229.cc)

   题意：给定一个数字N，问由2的幂组成的和为N的由多少种。2的幂从小到大排序，即不重复计数。

   `题解`：对答案进行dp，即定义dp\[i]为组成和为i的2的幂的种数。想象下，把1 2 3 4 5 . . . 排成一排，dp\[i]去更新dp\[i+1]和dp\[2*i]。答案便是dp\[N]。

   为什么是这样更新，看下面的1和2的等式。

   1 = 2^0

   2 = 2^0 + 2^0

   2 = 2^1

   一开始我写了[暴力枚举](./POJ-2229-timeout.cc)每种组合情况，这应该是一般人都会想到的做法，但显然会超时。另外看到数据范围是(1 <= N <= 1,000,000)，如果想到是dp的话，应该能猜到是一维的dp即对答案dp，这样时间复杂度才满足要求。

   时间复杂度：O(N)

4. ------

   小结：可以看到前3题都是类似的dp，一层一层的走，都是用一个已经更新好的状态(即从出发走到当前的最优状态)去更新这个状态能转移到的其他状态。能转移到的状态可能是接下来的一层如例题1，也可能是跳了几层如例题3，第i层去更新第2*i层。因为每一层都是从出发走到当前的最优值，这样层层更新下去，得到的结果一定是最优的。

   还有其他更新dp的方式，如有一个dp方程式dp[i] = dp[i-1] + dp[i-2]，这样的dp是dp[i]这个状态由dp[i-1]和dp[i-2]这两个状态组成/更新。

   例题1 2 3，我的dp实现方式都是用某个状态去更新它能转移到的状态。本质上这两张方法都是一样的。

   希望大家用类比的方式思考，理解。

5. 例题[POJ-2385](https://vjudge.net/problem/POJ-2385)， AC[源码](./POJ-2385.cc)

   题意：有两颗苹果数(标记为树0，树1)，每一秒钟从其中的一颗苹果树掉落一个苹果，你可以瞬间移动到一颗苹果树下，问当你第1秒钟站在苹果树0的下面，移动不差过W步时，T时间内最多能接到的苹果数量。

   `题解`：定义dp\[i][j]为从第0秒到第i秒钟，走了j步，能获得的最大苹果数量。时间序列，0秒 1秒 2秒 3秒 4秒 . . . 排成一排，状态转移就是要么移动，要么不动两种情况。另外因为第一秒在树0下面，那么走1步一定是在树1下面，走2步在树0下面，. . . ，所有走j步一定在(j%2)树下面。所有dp\[i][j]这个状态下，你是知道你在那颗树下面的。

   最后的答案就是std::max(dp\[T][0]，dp\[T][1]，. . . ，dp\[T][W])。

   例题1到例题5是不是很像一类题，但是你会发现例题1最简单，为什么呢？因为例题1显示的告诉你只能往对角线走，这其实就是告诉你dp的状态如何转移。到后面你会发现dp的转移很是关键，也是问题的难点。题目不会显示的告诉你如何转移，都要自己分析得出。

   时间复杂度：O(T*W)

6. 例题[POJ-3616](https://vjudge.net/problem/POJ-3616)， AC[源码](./POJ-3616.cc)

   题意：有M个时间区间，每个时间区间有个efficiency效率值。奶牛在某个时间区间工作后，必须休息R时间。问合理安排奶牛的工作，能获得最大多少效率值。

   `题解`：首先对区间按结束时间从小到大排序，然后定义dp[i]为从第1个时间区间到第i个时间区间，第i个时间区间工作时，能获得的最大效率值。那么dp[i]的状态只能由前面第1个时间区间到第i-1个时间区间转移而来。当然dp[i]的最小值为第i个时间区间本身的效率值，因为第i个时间区间本身要工作。

   最后的答案就是std::max(dp[1]，dp[2]，. . . ， dp[M])。

   对区间按结束时间从小到大排序，可以简单的理解为，越早结束就能更快接着干事情啦。

   此题的N是多余的条件，最开始围绕N想dp解法，一直没想出来，1 ≤ *N*≤ 1,000,000。

   例题6，我的dp方程是 某个状态从某些状态转移而来，而不是例题1到例题5的，从某个状态去更新它能转移到的其他状态。例题6，如果也用例题1到例题5的写法
   会发现dp的转移不是那么直接，好写。

   所以大家尽量两种dp的写法都要熟悉。

   时间复杂度：O(M*M)

7. 例题[POJ-3666](https://vjudge.net/problem/POJ-3666)， AC[源码](./POJ-3666.cc)

   题意：给你Ｎ个数字，问将Ｎ个数字修改为单调序列的最小修改量。修改量的定义见题目描述。

   `题解`：首先应该要想到，每个数字只能修改为原数组中的其中一个。把这Ｎ个数字排成一排，第一个数，第二个数，. . . ，第Ｎ个数，定义dp\[i][j]为第1个数到第i个数中，将第i个数排在末尾且将第i个数修改为第j大时，目前为止总共最小的修改量。那么状态转移方程为dp\[i][j] = std::min(dp\[i-1][k])，其中1<=k<=j。

   比如说有A[1] = 10, A[2]=11, A[3] = 12，A[4] = 13，那么第一大的数为10,第二大的为11，第三大的为12。那么dp\[２][４]的意思就是在第1个数到第2个数中，将第2个数修改为第4大的数，即11修改为13，然后排在末尾的最小修改量。

   按状态转移直接写的话是O(N^3)，但是有个很显然的优化，更新dp\[i][j]的时候，只要记录了上一层的dp\[i-1][1]，dp\[i-1][2]，. . . ，dp\[i-1][j]的最小值就行了。这样就不用遍历k了，降为O(N^2)。

   最开始做这题时，想了一天也没有想到解法。然后看了网上的题解，发现大部分题解，定义的dp状态都不是很清楚。另外这题本来是求单调非递减和单调非递增的最小修改量。但是数据只有单调非递减的，所以上面的dp解法都是针对单调非递减的，当然可以同理求单调非递增。

   时间复杂度：原始为O(N^3)优化后为O(N^2)
   
8. 例题[POJ-1742](https://vjudge.net/problem/POJ-1742)， AC[源码](./POJ-1742.cc)

   题意：给定N种数字，每种数字有C[i]种，判断是否可以从这些数字之中选出若干使他们的和恰好为K.1<=K<=m

   `题解`：可以直观的定义dp\[i][j]为前i种(第一种1到第i种)，能否组成j。状态转移便是dp\[i][j] |= dp\[i-1][j-k*A[i]]，其中"|="符号表示按位或。这样定义的dp时间复杂度为O(n\*m\*k)。

   如果我们换种定义方式，便可以优化到O(n*m)。现在我们定义dp\[i][j]为前i种硬币，组成和为j时，第i种最多还能剩下多少。如果前i种硬币不能组成和为j，则我们定义dp\[i][j] = -1。

   则状态的转移为，如果dp\[i-1][j]>=0，则dp\[i][j]显然为第i种本身的数量，如果dp\[i][j-A[i]]>=1，则dp\[i][j]为dp\[i][j-A[i]] - 1，其他情况dp\[i][j] = -1。

   注意dp\[i][j] = dp\[i][j-A[i]] - 1，相信大家看到这个式子脑袋里也会想到，dp\[i][j] = dp\[i][j-2*A[i]] - 2，dp\[i][j]= dp\[i][j-3\*A[i]] - 3，为什么其他状态不更新dp\[i][j]呢，只需要dp\[i][j-A[i]] 这个状态去更新dp\[i][j]呢？其实上面的递推式，dp\[i][j-A[i]]会被dp\[i][j-2\*A[i]]更新，所以dp\[i][j-2\*A[i]] 这个状态就不需要去更新dp\[i][j]了。

   另外这个题需要滚动数组的dp写法，不然会被卡内存。如果你不会滚动数组写法，你可以参考前面的**例题2**。你也可以对比此题的滚动数组写法，和原生的[memoryExceeded](./POJ-1742-memoryExceeded.cc)写法。
   
   另外这题如果把N种数字排成一排，将数看作重量等于价值的物品。则可以定义dp\[i][j]为前i个物品，恰好装进背包容量为j的最大价值。只要dp\[i][j]等于ｊ则表示前i种物品(数字)恰好可以拼凑和为j。这便转换为了经典的01背包问题。
   
   时间复杂度：O(n*m)

9. 例题[POJ-3046](https://vjudge.net/problem/POJ-3046)， AC[源码](./POJ-3046.cc)

   题意：蚂蚁有T个家族，每个家族里的蚂蚁没有区别，总共有A只蚂蚁，现在问：给出每个家族的蚂蚁数量，最多能组合成多少个不同的，集合元素个数为S~B的集合？
   
   简单的说就是：就是给你T个集合，每个集合num[i]个数，这些数排列组合能有多少个，个数为S~B的集合。
   
   `题解`：定义dp\[i][j]为前i种集合，选出j个数组成的组合个数。则状态转移方程便是
   
   <a href="https://www.codecogs.com/eqnedit.php?latex=dp[i][j]&space;=&space;\sum_{k=0}^{min(j,a[i])}dp[i-1][j-k]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i][j]&space;=&space;\sum_{k=0}^{min(j,a[i])}dp[i-1][j-k]" title="dp[i][j] = \sum_{k=0}^{min(j,a[i])}dp[i-1][j-k]" /></a>
   
   如果直接用上面的dp方程，那么时间复杂度便是O(T\*B*k)。下面我们对上式进行优化。
   
   当a[i]<=j时，将上式右边展开得
   
   <a href="https://www.codecogs.com/eqnedit.php?latex=dp[i][j]&space;=&space;dp[i-1][j]&space;&plus;&space;dp[i-1][j-1]&space;&plus;&space;...&space;&plus;&space;dp[i-1][j-a[i]]&space;&plus;&space;d[i-1][j-a[i]]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i][j]&space;=&space;dp[i-1][j]&space;&plus;&space;dp[i-1][j-1]&space;&plus;&space;...&space;&plus;&space;dp[i-1][j-a[i]]&space;&plus;&space;d[i-1][j-a[i]]" title="dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-a[i]] + d[i-1][j-a[i]]" /></a>
   
   <a href="https://www.codecogs.com/eqnedit.php?latex=dp[i][j-1]&space;=&space;dp[i-1][j-1]&space;&plus;&space;dp[i-1][j-2]&space;&plus;&space;...&space;&plus;&space;dp[i-1][j-a[i]]&space;&plus;&space;dp[i-1][j-a[i]-1]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i][j-1]&space;=&space;dp[i-1][j-1]&space;&plus;&space;dp[i-1][j-2]&space;&plus;&space;...&space;&plus;&space;dp[i-1][j-a[i]]&space;&plus;&space;dp[i-1][j-a[i]-1]" title="dp[i][j-1] = dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-a[i]] + dp[i-1][j-a[i]-1]" /></a>   
   
   所以<a href="https://www.codecogs.com/eqnedit.php?latex=dp[i][j]&space;=&space;dp[i-1][j]&space;&plus;&space;dp[i][j-1]&space;-&space;dp[i-1][j-a[i]-1]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i][j]&space;=&space;dp[i-1][j]&space;&plus;&space;dp[i][j-1]&space;-&space;dp[i-1][j-a[i]-1]" title="dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-a[i]-1]" /></a>
   
   当a[i]>j时，同理可得：
   
   <a href="https://www.codecogs.com/eqnedit.php?latex=dp[i][j]&space;=&space;dp[i-1][j]&space;&plus;&space;dp[i][j-1]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i][j]&space;=&space;dp[i-1][j]&space;&plus;&space;dp[i][j-1]" title="dp[i][j] = dp[i-1][j] + dp[i][j-1]" /></a>
   
   这样我们的dp方程就没有K这个变量，时间复杂度降为O(T*B)
   
   时间复杂度：原始O(T\*B\*K)，优化后为O(T\*B)
   
10. 例题[UVA-1025](https://vjudge.net/problem/UVA-1025)，AC[源码](./UVA-1025.cc)

    题意：有N个车站，一位间谍最开始在车站1，在T时候，他需要在车站N。从车站1有一些列车发车，从车站N也有一些列车发车，且车站1和车站N发的车到站后，便不在掉头往回开了，即是单向的。问间谍前往车站N，在路上所等待的最少时间是多少。

    `题解`：定义dp\[i][j]为在i车站，j时刻时，在路上所等待的总的最少时间。因为最开始在车站1我们是不知道要等待多少时间的，但是我们知道，如果间谍可以在T时间到达车站N，那么此时他的等待时间是0，这样我们可以倒着推出，他在车站1，时刻为0时，在路上所等待的总的最少时间。类似于在时间5，去推时间3的情况，因为时间是从0 1 2 3 4 5 6 . . . T增加的，我们现在是倒着推，即从时间T倒退它前面的时间的情况。

    所以显然dp\[i][j]的状态可以有3种转移，上个状态不乘车，上个状态来自左边乘车而来，上个状态来自右边乘车而来。

    这个题我最开始调了一晚上，没调出来。还有要注意for循环的顺序，在时刻T时，在车站1，车站2，. . . ，车站N的状态都是已知的，所有应该第一个循环是时间，里面的循环是车站。

    还有这个题的代码虽然AC了，但是在UVA的uDebug里面提供的数据，结果跑出来和它的不一样。可能是它后台的数据太弱了，`以后可能还会看一下是不是我的代码有bug`，尽管提交是AC的。

    时间复杂度：O(N*T)

11. 例题[POJ-2533](https://vjudge.net/problem/POJ-2533#author=0)，AC[源码](./POJ-2533-nlogn.cc)

    题意：求最长单调上升的子序列的长度。经典的LIS问题。

    `题解`：定义dp[i]为从第1个数到第i个数中，以第i个数为结尾的最长上升子序列的长度。

    状态转移为dp[i] = { dp[k] + 1, 1<=k<=i-1,A[k] < A[i]}。这样实现的dp，时间复杂度为O(n^2)，见[N^2实现](./POJ-2533.cc)。接下来我们换种dp的定义。

    反过来定义，我们定义dp[i]为长度为i的子序列，结尾的最小值。因为dp数组保存的是最小值，我们用最大值INF初始化。另外dp[i+1]的值一定比dp[i]的值大，所以显然dp数组是一个单调递增的。我们更新的时候就可以用二分查找更新了。假设输入a, 则更新第一个>=a的值，即std::lower_bound。为什么是更新第一个>=a的值？因为左边是<a的值，他的右边的>=a值，更新左边会使得左边保存的最小值变大，更新右边的话，当然是更新第一个才合理。

    时间复杂度：朴素的实现O(N^2)，优化后O(N*logN)

12. 例题[UVA-437](https://vjudge.net/problem/UVA-437)，AC[源码](./UVA-437.cc)

    题意：给定N种长方体block，每种无限多个，上面的严格小于下面的，问它们最多能堆叠的高度。

    `题解：`把这N种长方体，排成一排，前面的严格大于后面的。这样问题就和LIS问题一模一样了。定义dp\[i][j]为第1种到第i种，第i种长方体为结尾，且第i种长方体的第j条边为高，的最大高度。状态转移为dp\[i][j] =　std::max{ dp\[k][u] , 1<=k<=i-1, 且第i种长方体能够堆叠在第k种长方体上面}。

    另外这题也是经典的DAG例题。定义dp\[i][j]为第i种长方体，它的第j条边为高，从它出发所能获得的最大高度。想象一下，将dp\[i][j]这种状态当成图上的一个节点，图上边的构成便是状态的转移。显然只有长方体能够堆叠在上面才是合法的转移。这就是DAG图上的dp。

    我的代码实现是DAG。当然跑过的节点就记录下来，下次直接返回。这便是记忆化搜索。

    时间复杂度：O(N^2)

13. ------

    小结：可以看出来，目前为止。定义dp的状态一般为，第1种到第i种，什么怎么怎么样。或者定义第i种，什么怎么怎么样。

    另外前i种即第1种到第i种。我喜欢下标从1开始，不过一般书上都是从0开始的。

    如

    定义dp\[i][j]为从顶部向下走，走到第i层j列的最优分数；

    定义dp\[i][j]为第1种物品一直到第i种物品，在选取重量不超过j的情况下，能获得的最大渴望值D。

    对答案进行dp，即定义dp\[i]为组成和为i的2的幂的种数。

    定义dp\[i][j]为从第0秒到第i秒钟，走了j步，能获得的最大苹果数量。

    首先对区间按结束时间从小到大排序，然后定义dp[i]为从第1个时间区间到第i个时间区间，第i个时间区间工作时，能获得的最大效率值。

    定义dp\[i][j]为第1个数到第i个数中，将第i个数排在末尾且将第i个数修改为第j大时，目前为止总共最小的修改量。

    可以直观的定义dp\[i][j]为前i种(第一种1到第i种)，能否组成j。

    现在我们定义dp\[i][j]为前i种硬币，组成和为j时，第i种最多还能剩下多少。如果前i种硬币不能组成和为j，则我们定义dp\[i][j] = -1。

    定义dp\[i][j]为前i种集合，选出j个数组成的组合个数。

    定义dp\[i][j]为在i车站，j时刻时，在路上所等待的总的最少时间。

    定义dp[i]为从第1个数到第i个数中，以第i个数为结尾的最长上升子序列的长度。

    定义dp\[i][j]为第1种到第i种，第i种长方体为结尾，且第i种长方体的第j条边为高，的最大高度。

    定义dp\[i][j]为第i种长方体，它的第j条边为高，从它出发所能获得的最大高度。

14. 例题[HDU-1024](https://vjudge.net/problem/HDU-1024)，AC[源码](./HDU-1024.cc)

    题意：给n个数，将其分为m部分，各部分之间不能有交叉重叠，求m个部分加起来的最大和。

    `题解`：对答案进行dp，即答案求什么，就怎么定义状态。

    定义dp\[i]\[j][0]: 前i个元素构成j组，且最后一组不以第i个元素结尾的最大和; 

    定义dp\[i]\[j][1]: 前i个元素构成j组，且最后一组以第i个元素结尾的最大和;

    则状态的转移只需要考虑第i个元素，选还是不选即可：不选，不以第i个元素结尾，显然前i-1个已经构成了j组；选，即以第i个元素结尾，显然要么加入前面，要么自己单独构成一组。

    另外为什么这样定义的dp的写法，选取的区间是不相交的？因为在状态转移的时候，不存在相交的情况。

    这题我做了几天。网上的题解大多对状态的定义描述的不够清楚。此题也可以这样定义状态：dp\[i][j]表示前i个元素构成j组，且以第i个元素结尾的最大和。状态的转移为：dp\[i][j] = std::max(dp\[i-1][j] + A[i], dp\[k][j-1] + A[i] 1<=k<=i-1)。因为以第i个元素结尾，所以这样定义的状态一定要选第i个元素。显然第i个元素要么加入前面的一组(即dp\[i-1][j])，要么自己单独构成一组(即dp[k][j-1])。

    此外这题必须要滚动数组，不然会超内存。滚动数组的写法和前面的例题(如**例题8**)是一样的，特别需要注意，滚动几次后，滚动数组需要重新初始化。

    时间复杂度:O(N*M)

16. 例题[UVA-12563](https://vjudge.net/problem/UVA-12563)，AC[源码](./UVA-12563.cc)

    题意：给定n个数，问在t时间，你能选择最多的歌曲数量。并且也输出在选择最多歌曲数量的情况下，唱的时间。

    `题解`：定义dp\[i][j]为前i个数，恰好装进容量为j时，能选择的最多的歌曲数量。

    状态转移也是对第i个数，选择和不选择两种情况。背包容量是t-=1，因为要留1秒钟选择耗时678的这首歌曲.

    本题看成把n个数重量为a[i]，价值为1，装进背包容量为t的模型，那么问题就转化为01背包问题了。如果本题你不能轻松的看出是一道01背包问题，那么建议你再去精读**背包九讲**。

    另外本题，我最开始读错题了。我读成，求最多能唱的时间，然后再输出在最多能唱的时间下，输出最多能选择的歌曲数目。

    另外，本题虽然写着t<=1e9，但是题目说了，最多50首歌曲，每首歌曲都不差过３分钟，所有远远达不到1e9的背包容量。

    时间复杂度：O(n*t)

16. 

    

    

    

    

    

    

    

    

    

    

    









